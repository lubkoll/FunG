<p>Now let us generate the function $W:\mathbb{R}^{n,n}\to \mathbb{R}$ with \[W(F)=c_{Cells}(\iota_1-n)+ \frac{k_1}{k_2}\left(\exp(k_2(\kappa\iota_1+(1-3\kappa)\iota_4-1)^2)\right),\] which constitutes an anisotropic model for adipose tissue. In this context the invariants depend on the left Cauchy-Green strain tensor $F^T F$, which can be generated by the (template) function <code>strainTensor</code>. The implementation of this model is</p>

<pre class="code-style boxshadow">#include "fung.hh"

template &lt;class Matrix&gt;
auto generateAdiposeTissue(double cCells, double k1, double k2,
             double kappa, const Matrix&amp; M, const Matrix&amp; F, int n = dim<Mat>())
{
  using namespace FunG;
  using namespace FunG::LinearAlgebra;

  auto aniso = kappa*i1(F) + (1-3*kappa) * i4(F,M) - 1;
  auto materialLaw = cCells*( i1(F) - n ) + (k1/k2) * ( exp(k2*aniso^2) - 1 );

  return finalize( materialLaw( strainTensor(F) ) );
}
</pre>

<p>For constant size matrices usage is as follows (assuming that the material parameters, the structural tensor M, the deformation gradient F and perturbations dF0, dF1, dF2 of the latter are given):</p>

<pre class="code-style boxshadow">auto f = generateAdiposeTissue(cCells,k1,k2,kappa,M,F);

f.update(F) //  change function argument

double value = f();
double firstDerivative  = f.d1(dF0);
double secondDerivative = f.d2(dF0,dF1);
double thirdDerivative  = f.d3(dF0,dF1,dF2);
</pre>

<p>Observe that the derivatives are DIRECTIONAL derivatives. This approach admits to work with any (reasonable) input types.

<p>Take care to not use functions such as 'exp' with built-in arithmetic types, since in this case the corresponding functions from  are called and the resulting value is treated as constant.</p>

<p>Also note that the <code>operator^(int k)</code> is only defined for k=2. For scalar valued functions you may use <code>Pow&lt;dividend,divisor&gt;</code> to represent rational powers.</p> 
