\hypertarget{namespaceFunG}{}\section{FunG Namespace Reference}
\label{namespaceFunG}\index{FunG@{FunG}}


Main namespace of the FunG library.  


\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \hyperlink{namespaceFunG_1_1Access}{Access}
\item 
 \hyperlink{namespaceFunG_1_1Checks}{Checks}
\begin{DoxyCompactList}\small\item\em Static checks for the presence of different operators and functions. \end{DoxyCompactList}\item 
 \hyperlink{namespaceFunG_1_1Concepts}{Concepts}
\begin{DoxyCompactList}\small\item\em Requirements on input types. \end{DoxyCompactList}\item 
 \hyperlink{namespaceFunG_1_1LinearAlgebra}{Linear\+Algebra}
\begin{DoxyCompactList}\small\item\em Functionality from linear algebra such as (modified) principal and mixed matrix invariants. \end{DoxyCompactList}\item 
 \hyperlink{namespaceFunG_1_1MathematicalOperations}{Mathematical\+Operations}
\begin{DoxyCompactList}\small\item\em Mathematical operations and corresponding differentation rules. \end{DoxyCompactList}\item 
 \hyperlink{namespaceFunG_1_1Meta}{Meta}
\end{DoxyCompactItemize}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structFunG_1_1ACos}{A\+Cos}
\begin{DoxyCompactList}\small\item\em Arc cosine function including first three derivatives (based on acos(double) in $<$cmath$>$). \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1ASin}{A\+Sin}
\begin{DoxyCompactList}\small\item\em Arc sine function including first three derivatives (based on asin(double) in $<$cmath$>$). \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Constant}{Constant}
\begin{DoxyCompactList}\small\item\em Wrap a constant. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Cos}{Cos}
\begin{DoxyCompactList}\small\item\em Cosine function including first three derivatives (based on cos(double) in $<$cmath$>$). \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Decay}{Decay}
\begin{DoxyCompactList}\small\item\em Identity, i.\+e. \hyperlink{structFunG_1_1Decay_a4b2916cbb7c8587ab3fccc9b896b9df4}{Decay$<$\+F$>$\+::type} == F \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Decay_3_01F_00_01void__t_3_01Checks_1_1Try_1_1NestedType_1_1PlainObject_3_01F_01_4_01_4_01_4}{Decay$<$ F, void\+\_\+t$<$ Checks\+::\+Try\+::\+Nested\+Type\+::\+Plain\+Object$<$ F $>$ $>$ $>$}
\begin{DoxyCompactList}\small\item\em Underlying type for expression templates of the Eigen library. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Erf}{Erf}
\begin{DoxyCompactList}\small\item\em Error function including first three derivatives. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Exp}{Exp}
\begin{DoxyCompactList}\small\item\em Exponential function including first three derivatives. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Exp2}{Exp2}
\begin{DoxyCompactList}\small\item\em Function $2^x$ including first three derivatives. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Identity}{Identity}
\begin{DoxyCompactList}\small\item\em Identity mapping $ f(x)=x $. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1is__arithmetic}{is\+\_\+arithmetic}
\begin{DoxyCompactList}\small\item\em Specialize this template class to register arithmetic types that are not built-\/in. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1LN}{LN}
\begin{DoxyCompactList}\small\item\em Natural logarithm including first three derivatives. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Log10}{Log10}
\begin{DoxyCompactList}\small\item\em Common (base 10) logarithm including first three derivatives. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Log2}{Log2}
\begin{DoxyCompactList}\small\item\em Base 2 logarithm including first three derivatives. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1MathOpTraits}{Math\+Op\+Traits}
\item 
struct \hyperlink{structFunG_1_1MathOpTraits_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__arithmetic_3_01T_01_4_1_1value_01_4_01_4}{Math\+Op\+Traits$<$ T, std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+arithmetic$<$ T $>$\+::value $>$ $>$}
\item 
class \hyperlink{classFunG_1_1NonSymmetricMatrixException}{Non\+Symmetric\+Matrix\+Exception}
\begin{DoxyCompactList}\small\item\em Exception for non-\/symmetric matrices if symmetric matrices are required. \end{DoxyCompactList}\item 
class \hyperlink{classFunG_1_1OutOfDomainException}{Out\+Of\+Domain\+Exception}
\begin{DoxyCompactList}\small\item\em Exception for scalar function arguments that are outside the domain of the function. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Pow}{Pow}
\begin{DoxyCompactList}\small\item\em Power function with rational exponent $ k = \frac{dividend}{divisor} $ including first three derivatives. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Sin}{Sin}
\begin{DoxyCompactList}\small\item\em Sine function including first three derivatives (based on sin(double) in $<$cmath$>$). \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Tan}{Tan}
\begin{DoxyCompactList}\small\item\em Tangent function including first three derivatives. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Variable}{Variable}
\begin{DoxyCompactList}\small\item\em Independent variable. Can be uniquely identified by its id. \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Zero}{Zero}
\begin{DoxyCompactList}\small\item\em Specialize this struct for your matrix type if a zero matrix cannot be generated via Matrix(0.). \end{DoxyCompactList}\item 
struct \hyperlink{structFunG_1_1Zero_3_01Matrix_00_01void__t_3_01Checks_1_1TryCallToFill_3_01Matrix_01_4_01_4_01_4}{Zero$<$ Matrix, void\+\_\+t$<$ Checks\+::\+Try\+Call\+To\+Fill$<$ Matrix $>$ $>$ $>$}
\begin{DoxyCompactList}\small\item\em Specialization for the case that a matrix can be set to zero by calling the member function fill(0). \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{group__CMathGroup_ga70c69680e967f5ccb79c07e50d44739d}{Sqrt} = \hyperlink{structFunG_1_1Pow}{Pow}$<$ 1, 2 $>$
\begin{DoxyCompactList}\small\item\em Square root including first three derivatives (based on sqrt(double) in $<$cmath$>$). \end{DoxyCompactList}\item 
using \hyperlink{group__CMathGroup_gaff369d639f7a316b3f22982e806cb45f}{Cbrt} = \hyperlink{structFunG_1_1Pow}{Pow}$<$ 1, 3 $>$
\begin{DoxyCompactList}\small\item\em Third root including first three derivatives (based on sqrt(double) in $<$cmath$>$). \end{DoxyCompactList}\item 
using \hyperlink{group__CMathGroup_gab63795eecd1e9a55ea26b24125053f2d}{Cbrt2} = \hyperlink{structFunG_1_1Pow}{Pow}$<$ 2, 3 $>$
\begin{DoxyCompactList}\small\item\em Third root squared including first three derivatives (based on sqrt(double) in $<$cmath$>$). \end{DoxyCompactList}\item 
{\footnotesize template$<$class F $>$ }\\using \hyperlink{namespaceFunG_a7ff91644f18a190ac3d4fc9e970ebe2e}{decay\+\_\+t} = typename \hyperlink{structFunG_1_1Decay}{Decay}$<$ std\+::decay\+\_\+t$<$ F $>$ $>$\+::type
\begin{DoxyCompactList}\small\item\em \hyperlink{namespaceFunG_1_1Access}{Access} underlying type (if it is hidden by expression templates). \end{DoxyCompactList}\item 
{\footnotesize template$<$class F $>$ }\\using \hyperlink{namespaceFunG_a40f6d0896c1e3837d442d39418a4f609}{remove\+\_\+reference\+\_\+t} = typename \hyperlink{structFunG_1_1Decay}{Decay}$<$ std\+::remove\+\_\+reference\+\_\+t$<$ F $>$ $>$\+::type
\begin{DoxyCompactList}\small\item\em \hyperlink{namespaceFunG_1_1Access}{Access} underlying type (if it is hidden by expression templates). \end{DoxyCompactList}\item 
{\footnotesize template$<$class... Types$>$ }\\using \hyperlink{namespaceFunG_a0cde667596590eb8d32e4a5ee76ddbb9}{void\+\_\+t} = typename Detail\+::voider$<$ Types... $>$\+::type
\begin{DoxyCompactList}\small\item\em Most fascinating type ever. Is void for all input types. \end{DoxyCompactList}\item 
{\footnotesize template$<$class F , int id$>$ }\\using \hyperlink{namespaceFunG_a1c6fc5c4c7cd6678b9de8962c14b86b5}{Variable\+\_\+t} = typename Variable\+Detail\+::\+Variable\+Type$<$ std\+::decay\+\_\+t$<$ F $>$, id $>$\+::type
\begin{DoxyCompactList}\small\item\em Get underlying type of variable with index id. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Function$<$\+Function$>$()$>$$>$ }\\auto \hyperlink{group__CMathGroup_gae9b7d3a479bcd8d48cf25f1c29edefb9}{acos} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \arccos\circ f $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ Function $>$() $>$$>$ }\\auto \hyperlink{group__CMathGroup_gad26443b289325876cffdaadfca770d51}{asin} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \arcsin\circ f $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ Function $>$() $>$$>$ }\\auto \hyperlink{group__CMathGroup_ga7e9b2ac717cd2350663293cb66ba6cbd}{cos} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \cos\circ f $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ Function $>$() $>$$>$ }\\auto \hyperlink{group__CMathGroup_gaa0d608a0906520bd48b7e0036e560afa}{erf} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \erf\circ f $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Function$<$\+Function$>$()$>$$>$ }\\auto \hyperlink{group__CMathGroup_ga00135c8521411f13813f9b972ea4e231}{exp} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \exp(f) $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Function$<$\+Function$>$()$>$$>$ }\\auto \hyperlink{group__CMathGroup_ga7724faf7db6e9583ac91df322c26ecf5}{exp2} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $2^f$. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Function$<$\+Function$>$()$>$$>$ }\\auto \hyperlink{group__CMathGroup_ga31313571b08f65b853643e14fc8fc714}{ln} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \mathrm{ln}\circ f $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Function$<$\+Function$>$()$>$$>$ }\\auto \hyperlink{group__CMathGroup_gae9506f4e0e6fad4f756f636044697bfe}{log10} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \mathrm{log}_{10}\circ f $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Function$<$\+Function$>$()$>$$>$ }\\auto \hyperlink{group__CMathGroup_gacd6be7e9de7bbd54c852f0acf0c7d2c2}{log2} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \mathrm{log}_{2}\circ f $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ Function $>$() $>$$>$ }\\auto \hyperlink{group__CMathGroup_ga136c890475e48f88469a737d95368d05}{sqrt} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \sqrt{f} $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ Function $>$() $>$$>$ }\\auto \hyperlink{group__CMathGroup_gaa7f2552adfb8ec41aeb685adddd8bf98}{cbrt} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \sqrt[3]{f} $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ Function $>$() $>$$>$ }\\auto \hyperlink{group__CMathGroup_gafd27322fb64c6df3366f384c93819a06}{cbrt2} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \sqrt[3]{f^2}$. \end{DoxyCompactList}\item 
{\footnotesize template$<$int k, int l, class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ Function $>$() $>$$>$ }\\auto \hyperlink{group__CMathGroup_gaecae6fa60bbfc0eb1867581ee4577d4e}{pow} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ f^{k/l} $. \end{DoxyCompactList}\item 
{\footnotesize template$<$int k, class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ Function $>$() $>$$>$ }\\auto \hyperlink{group__CMathGroup_gab52ffe2efd379aad7ea322de46103465}{pow} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ f^k,\ k\in\mathbb{N}$. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ Function $>$() $>$$>$ }\\auto \hyperlink{group__CMathGroup_ga663fdbe7a8977cba529c7c33981b7738}{sin} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \sin\circ f $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Function , class  = std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ Function $>$() $>$$>$ }\\auto \hyperlink{group__CMathGroup_gae03f57bd4efb4449ad1dc60cb74c742d}{tan} (const Function \&f)
\begin{DoxyCompactList}\small\item\em Generate $ \tan\circ f $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Arg $>$ }\\auto \hyperlink{namespaceFunG_abcfb38c2e995436816ea884803302f2d}{const\+Ref} (const Arg \&x)
\begin{DoxyCompactList}\small\item\em Generate a constant function that stores its argument as constant reference. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Arg $>$ }\\constexpr auto \hyperlink{namespaceFunG_a939d13d36c194b402715f12a28147cdc}{constant} (Arg x)
\begin{DoxyCompactList}\small\item\em Wrap a constant. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix , int offset = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_gac269eefc1abb994044e1634c20a98061}{incompressible\+Adipose\+Tissue\+\_\+\+Sommer\+Holzapfel} (double c\+Cells, double k1, double k2, double kappa, const Matrix \&M, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Model for adipose tissue of {\bfseries [Sommer2013]}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix , int offset = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_ga01ab128bcf179f4431b0270179af9e20}{incompressible\+Adipose\+Tissue\+\_\+\+Sommer\+Holzapfel} (const Matrix \&M, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Model for adipose tissue of {\bfseries [Sommer2013]}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Inflation , class Compression , class Matrix , int offset = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_ga5c3388564c0420b62e58f48c739d27f1}{compressible\+Adipose\+Tissue\+\_\+\+Sommer\+Holzapfel} (double c\+Cells, double k1, double k2, double kappa, double d0, double d1, const Matrix \&M, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Compressible version of the model for adipose tissue of {\bfseries [Sommer2013]}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Inflation , class Compression , class Matrix , int offset = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_ga27bb3f7c579ce8c21a69ea4d4d0169d7}{compressible\+Adipose\+Tissue\+\_\+\+Sommer\+Holzapfel} (double d0, double d1, const Matrix \&M, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Compressible version of the model for adipose tissue of {\bfseries [Sommer2013]}. Material parameters are taken from the same publication, Table 2, i.\+e. $c_\mathrm{Cells}=0.15 (\,\mathrm{kPa})$, $k_1=0.8 (\,\mathrm{kPa})$, $k_2=47.3$ and $\kappa=0.09$. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix , int offset = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_gafcc36a1958899ca9246c4c1b3c9bfd85}{incompressible\+Muscle\+Tissue\+\_\+\+Martins} (double c, double b, double A, double a, const Matrix \&M, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Incompressible version of the model for muscle tissue of {\bfseries [Martins1998]}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix , int offset = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_ga9e414585a90b1988e9fa88d17d875055}{incompressible\+Muscle\+Tissue\+\_\+\+Martins} (const Matrix \&M, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Incompressible version of the model for muscle tissue of {\bfseries [Martins1998]}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Inflation , class Compression , class Matrix , int offset = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_gad831914c493a3da04ed40c3c0ce87a62}{compressible\+Muscle\+Tissue\+\_\+\+Martins} (double c, double b, double A, double a, double d0, double d1, const Matrix \&M, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Compressible version of the model for muscle tissue of {\bfseries [Martins1998]}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Inflation , class Compression , class Matrix , int offset = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_ga46a70ccb2285e12addad87b6a8aaaae8}{compressible\+Muscle\+Tissue\+\_\+\+Martins} (double d0, double d1, const Matrix \&M, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Compressible version of the model for muscle tissue of {\bfseries [Martins1998]}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix , int n = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_gaa20bf15ef6976d64d89490429035b2c4}{incompressible\+Skin\+\_\+\+Hendriks} (double c0, double c1, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Model for skin tissue of {\bfseries [Hendriks2005]}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix , int n = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_gad8653218bd2afb4e3cfd601a5142956c}{incompressible\+Skin\+\_\+\+Hendriks} (const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Model for skin tissue of {\bfseries [Hendriks2005]}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Inflation\+Penalty , class Compression\+Penalty , class Matrix , int n = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_ga07b4c52c6ecf7e72f73ab5832fb262cd}{compressible\+Skin\+\_\+\+Hendriks} (double c0, double c1, double d0, double d1, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Compressible version of the model for skin tissue of {\bfseries [Hendriks2005]}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Inflation\+Penalty , class Compression\+Penalty , class Matrix , int n = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Biomechanics_ga42721e772b7eada1b0bca98247ad440f}{compressible\+Skin\+\_\+\+Hendriks} (double d0, double d1, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Compressible version of the model for skin tissue of {\bfseries [Hendriks2005]}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Scalar , class Vector $>$ }\\auto \hyperlink{namespaceFunG_aab17a1468e61f58564333b3fcd7900d6}{heat\+Model} (double c, double d, Scalar u, const Vector \&du)
\begin{DoxyCompactList}\small\item\em Weak model for nonlinear heat transfer $ (c+du^2)\nabla u $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix , int n = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Rubber_gace19173e33490aadd36ae3a03fd1d85c}{incompressible\+Mooney\+Rivlin} (double c0, double c1, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Generate an \char`\"{}incompressible\char`\"{} Mooney-\/\+Rivlin material law $ W(F)=c_0\iota_1(F^T F) + c_1\iota_2(F^T F) $, where $\iota_1$ is the first and $\iota_2$ the second principal matrix invariant. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Inflation\+Penalty , class Compression\+Penalty , class Matrix , int n = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Rubber_ga9a1894daa10a0bdcc620c6c41ecb6f19}{compressible\+Mooney\+Rivlin} (double c0, double c1, double d0, double d1, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Generate a compressible Mooney-\/\+Rivlin material law $ W(F)=c_0\iota_1(F^T F) + c_1\iota_2(F^T F) + d_0\Gamma_\mathrm{In}(\det(F))+d_1\Gamma_\mathrm{Co}(\det(F)) $, where $\iota_1$ is the first and $\iota_2$ the second principal matrix invariant. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix , int n = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Rubber_ga5bb28aef7006413775791998936d6b81}{incompressible\+Neo\+Hooke} (double c, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Generate an \char`\"{}incompressible\char`\"{} neo-\/\+Hookean material law $ W(F)=c\iota_1(F^T F) $, where $\iota_1$ is the first principal matrix invariant . \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix , int n = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Rubber_gaf6f5ab6a379ef03d513acc5042731a01}{modified\+Incompressible\+Neo\+Hooke} (double c, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Generate an \char`\"{}incompressible\char`\"{} neo-\/\+Hookean material law $ W(F)=c\bar\iota_1(F^T F) $, where $\bar\iota_1$ is the modified first principal matrix invariant. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Inflation\+Penalty , class Compression\+Penalty , class Matrix , int n = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Rubber_gac5c39cd9de55f4f0220a806cf28a7b30}{compressible\+Neo\+Hooke} (double c, double d0, double d1, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Generate a compressible neo-\/\+Hookean material law $ W(F)=c\iota_1(F^T F)+d_0\Gamma_\mathrm{In}(\det(F))+d_1\Gamma_\mathrm{Co}(\det(F)) $, where $\iota_1$ is the first principal matrix invariant. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Inflation\+Penalty , class Compression\+Penalty , class Matrix , int n = Linear\+Algebra\+::dim$<$\+Matrix$>$()$>$ }\\auto \hyperlink{group__Rubber_gac10942df03f037afdf0a81d330361a6b}{modified\+Compressible\+Neo\+Hooke} (double c, double d0, double d1, const Matrix \&F)
\begin{DoxyCompactList}\small\item\em Generate a compressible neo-\/\+Hookean material law $ W(F)=c\bar\iota_1(F^T F)+d_0\Gamma_\mathrm{In}(\det(F))+d_1\Gamma_\mathrm{Co}(\det(F)) $, where $\bar\iota_1$ is the modified first principal matrix invariant. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Inflation , class Compression , class Matrix $>$ }\\auto \hyperlink{namespaceFunG_ad26faeb264bb4b1cd7e70f3811c366c8}{volumetric\+Penalty} (double d0, double d1, const Matrix \&A)
\begin{DoxyCompactList}\small\item\em Create volumetric penalty function composed of a penalty for inflation and one for compression. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix $>$ }\\auto \hyperlink{namespaceFunG_aaf30b9c36ed86e01b94f6b7c1d95cae8}{volumetric\+Quad\+And\+Log} (double d0, double d1, const Matrix \&A)
\begin{DoxyCompactList}\small\item\em Create the volumetric penalty function $ d_0 j^2 + d_1 \log(j),\ j=\det(A) $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix $>$ }\\auto \hyperlink{namespaceFunG_adf4be5df85ea9df10cc9e11c11aaeb7b}{volumetric\+Hartmann\+Neff} (double d0, double d1, const Matrix \&A)
\begin{DoxyCompactList}\small\item\em Create the volumetric penalty function $ d_0 j^5 + d_1 j^{-5},\ j=\det(A) $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix $>$ }\\auto \hyperlink{namespaceFunG_a4784211358c877f05ad9426850303273}{yield\+Surface} (double beta, double offset, Matrix sigma=\hyperlink{group__LinearAlgebraGroup_ga88a596b8526c0ed98ce241244fb85948}{Linear\+Algebra\+::unit\+Matrix}$<$ Matrix $>$())
\begin{DoxyCompactList}\small\item\em Yield surface $ \frac{\beta}{3}\iota_1(\sigma) + J_2(\sigma)-offset $, where $\iota_1$ is the first principal and $J_2$ is the second deviatoric invariant. \end{DoxyCompactList}\item 
{\footnotesize template$<$class F $>$ }\\auto \hyperlink{namespaceFunG_ac59f2ececc3cd451860776320a4a93d5}{finalize} (F \&\&f)
\begin{DoxyCompactList}\small\item\em Finish function definition. \end{DoxyCompactList}\item 
{\footnotesize template$<$class F , class G , std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ F $>$ $>$()$\vert$$\vert$\+Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ G $>$ $>$() $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_a24bb5d609b022030afda2d8589cf5509}{operator+} (F \&\&f, G \&\&g)
\begin{DoxyCompactList}\small\item\em overload of \char`\"{}+\char`\"{}-\/operator for the generation of functions. \end{DoxyCompactList}\item 
{\footnotesize template$<$class F , class G , std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ F $>$ $>$()$\vert$$\vert$\+Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ G $>$ $>$() $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_a267562e725c73ece1c1d057b5f29511f}{operator$\ast$} (F \&\&f, G \&\&g)
\begin{DoxyCompactList}\small\item\em overload of \char`\"{}$\ast$\char`\"{}-\/operator for the generation of functions. \end{DoxyCompactList}\item 
{\footnotesize template$<$class F , class G , std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ F $>$ $>$()$\vert$$\vert$\+Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ G $>$ $>$() $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_ac73eb907f3d29a9ea60513a43c658270}{dot} (F \&\&f, G \&\&g)
\begin{DoxyCompactList}\small\item\em overload of \char`\"{}dot\char`\"{}-\/function for the generation of functions. \end{DoxyCompactList}\item 
{\footnotesize template$<$class F , std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ F $>$ $>$() $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_a94273e3ea80324e591bb98ae3c051221}{operator$^\wedge$} (F \&\&f, int k)
\begin{DoxyCompactList}\small\item\em overload of \char`\"{}$^\wedge$\char`\"{}-\/operator for the generation of functions. \end{DoxyCompactList}\item 
{\footnotesize template$<$class F , std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ F $>$ $>$() $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_ac4ffc0754104af6ddf114e154251db78}{squared} (F \&\&f)
\begin{DoxyCompactList}\small\item\em Generate squared function. \end{DoxyCompactList}\item 
{\footnotesize template$<$class F , class G , std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ F $>$ $>$()\&\&\+Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ G $>$ $>$() $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_a65436d4494e99629b0177d0df7634a6b}{operator$<$$<$} (F \&\&f, G \&\&g)
\begin{DoxyCompactList}\small\item\em overload of \char`\"{}$<$$<$\char`\"{}-\/operator for chaining functions $f$ and $g$ to $ f \circ g $. \end{DoxyCompactList}\item 
{\footnotesize template$<$class F , class G , std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ F $>$ $>$()$\vert$$\vert$\+Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ G $>$ $>$() $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_a3af04c2ef5c1b206feb75fffd298cbbf}{operator-\/} (F \&\&f, G \&\&g)
\begin{DoxyCompactList}\small\item\em overload of \char`\"{}-\/\char`\"{}-\/operator for the generation of functions. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Arg $>$ }\\auto \hyperlink{namespaceFunG_a165e879e76d3a2a8906938f3658445ce}{identity} (const Arg \&x)
\begin{DoxyCompactList}\small\item\em Construct Identity$<$\+Arg$>$(x). \end{DoxyCompactList}\item 
{\footnotesize template$<$class Scalar , class Other\+Scalar , int n, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::\+Has\+::\+Free\+::multiplication$<$ Dune\+::\+Field\+Vector$<$ Scalar, n $>$, Dune\+::\+Field\+Vector$<$ Other\+Scalar, n $>$ $>$() $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_a5e258023361844926f485229c62a733b}{operator$\ast$} (const Dune\+::\+Field\+Vector$<$ Scalar, n $>$ \&a, const Dune\+::\+Field\+Vector$<$ Other\+Scalar, n $>$ \&b)
\begin{DoxyCompactList}\small\item\em Computation of the l2 scalar product for Dune\+::\+Field\+Vector. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Scalar , class Other\+Scalar , int n, int m, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::\+Has\+::\+Free\+::multiplication$<$ Dune\+::\+Field\+Matrix$<$ Scalar, n, m $>$, Dune\+::\+Field\+Vector$<$ Other\+Scalar, m $>$ $>$() $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_abadb8da34a5abc3dde0107231ab91c6f}{operator$\ast$} (const Dune\+::\+Field\+Matrix$<$ Scalar, n, m $>$ \&A, const Dune\+::\+Field\+Vector$<$ Other\+Scalar, m $>$ \&x)
\begin{DoxyCompactList}\small\item\em Define matrix-\/vector multiplication for Dune\+::\+Field\+Matrix and Dune\+::\+Field\+Vector, i.\+e. compute $y=Ax$. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Scalar , class Other\+Scalar , int n, int m, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::\+Has\+::\+Free\+::multiplication$<$ Dune\+::\+Field\+Vector$<$ Other\+Scalar, n $>$, Dune\+::\+Field\+Matrix$<$ Scalar, n, m $>$ $>$() $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_a19a9d7b55b56f5101560034413a1dbfe}{operator$\ast$} (const Dune\+::\+Field\+Vector$<$ Other\+Scalar, n $>$ \&x, const Dune\+::\+Field\+Matrix$<$ Scalar, n, m $>$ \&A)
\begin{DoxyCompactList}\small\item\em Define vector-\/matrix multiplication for Dune\+::\+Field\+Matrix and Dune\+::\+Field\+Vector, i.\+e. compute $x^T A = y^T$ resp. $y=A^T x$. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Arg , class Scalar\+Arg , std\+::enable\+\_\+if\+\_\+t$<$ is\+\_\+arithmetic$<$ Scalar\+Arg $>$\+::value $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::is\+Function$<$ Arg $>$()\&\&!is\+\_\+arithmetic$<$ Arg $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::\+Has\+::\+Free\+::multiplication$<$ Scalar\+Arg, Arg $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::\+Has\+::\+Mem\+Op\+::in\+Place\+Multiplication$<$ Arg, Scalar\+Arg $>$() $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_ac71b238827eda3b6518c39e49447bdeb}{operator$\ast$} (Scalar\+Arg a, Arg x)
\begin{DoxyCompactList}\small\item\em Defines operator$\ast$ for multiplication with arithmetic types from the left if undefined and in-\/place multiplication (operator$\ast$=()) is supported. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Arg , class Scalar\+Arg , std\+::enable\+\_\+if\+\_\+t$<$ is\+\_\+arithmetic$<$ Scalar\+Arg $>$\+::value $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::is\+Function$<$ Arg $>$()\&\&!is\+\_\+arithmetic$<$ Arg $>$\+::value $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::\+Has\+::\+Free\+::multiplication$<$ Scalar\+Arg, Arg $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::\+Has\+::\+Mem\+Op\+::in\+Place\+Multiplication$<$ Arg, Scalar\+Arg $>$() $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_a49623beb215912a02388a11cc18f15fe}{operator$\ast$} (Arg x, Scalar\+Arg a)
\begin{DoxyCompactList}\small\item\em Defines operator$\ast$ for multiplication with arithmetic types from the right if undefined and in-\/place multiplication (operator$\ast$=()) is supported. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Arg1 , class Arg2 , std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::is\+Function$<$ Arg1 $>$()\&\&!\+Checks\+::is\+Function$<$ Arg2 $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !is\+\_\+arithmetic$<$ Arg1 $>$()\&\&!is\+\_\+arithmetic$<$ Arg2 $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::\+Has\+::\+Free\+::multiplication$<$ Arg1, Arg2 $>$()\&\&\+Checks\+::\+Has\+::\+Mem\+Op\+::in\+Place\+Multiplication$<$ Arg1, Arg2 $>$() $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_ad023f2d2273af693f2b4ebceeb296dc8}{operator$\ast$} (Arg1 x, const Arg2 \&y)
\begin{DoxyCompactList}\small\item\em Defines operator$\ast$ for multiplication of non-\/arithmetic types if undefined and in-\/place multiplication (operator$\ast$=()) is supported. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Arg , std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::is\+Function$<$ Arg $>$()\&\&!is\+\_\+arithmetic$<$ Arg $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::\+Has\+::\+Free\+::summation$<$ Arg $>$()\&\&\+Checks\+::\+Has\+::\+Mem\+Op\+::in\+Place\+Summation$<$ Arg $>$() $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_a063d3e8c19dbea3ee1396736fecb64e1}{operator+} (Arg x, const Arg \&y)
\begin{DoxyCompactList}\small\item\em Defines operator+ if not yet defined and in-\/place summation (operator+=()) is supported. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix , std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Constant\+Size$<$ Matrix $>$()$>$ $\ast$  = nullptr$>$ }\\Matrix \hyperlink{namespaceFunG_a0211d0d26c669d56b5113fd2292902e5}{add\+Transposed} (Matrix \&A)
\begin{DoxyCompactList}\small\item\em Overwrites $A$ with $A+A^T$. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix , class Index , class  = std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+integral$<$\+Index$>$\+::value $>$$>$ }\\decltype(auto) \hyperlink{macros_8hh_a03b9da186125795e5afa49d0ef1cc32f}{F\+U\+N\+G\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE} \hyperlink{namespaceFunG_aae631e6149505bdfc0b1c6162b370c7f}{at} (Matrix \&\&A, Index i, Index j)
\begin{DoxyCompactList}\small\item\em \hyperlink{namespaceFunG_1_1Access}{Access} matrix entry $A_{ij}$. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Vector , class Index , class  = std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+integral$<$\+Index$>$\+::value $>$$>$ }\\decltype(auto) \hyperlink{macros_8hh_a03b9da186125795e5afa49d0ef1cc32f}{F\+U\+N\+G\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE} \hyperlink{namespaceFunG_aa40271c9228c5ccee8a4973f27918630}{at} (Vector \&\&v, Index i)
\begin{DoxyCompactList}\small\item\em \hyperlink{namespaceFunG_1_1Access}{Access} vector entry. \end{DoxyCompactList}\item 
{\footnotesize template$<$class F , class Arg , std\+::enable\+\_\+if\+\_\+t$<$!\+Detail\+::\+Has\+Update\+Without\+Index$<$ F, Arg $>$\+::value $>$ $\ast$  = nullptr$>$ }\\void \hyperlink{namespaceFunG_a3b9d2e5d07b30c2ee26703b33e9adb9e}{update\+\_\+if\+\_\+present} (F \&\&, Arg \&\&)
\item 
{\footnotesize template$<$int id, class F , class Arg , std\+::enable\+\_\+if\+\_\+t$<$!\+Detail\+::\+Has\+Update\+With\+Index$<$ F, Arg, id $>$\+::value $>$ $\ast$  = nullptr$>$ }\\void \hyperlink{namespaceFunG_aed5ddbef97c98202e818bca2b74c75d2}{update\+\_\+if\+\_\+present} (F \&\&, Arg \&\&)
\item 
{\footnotesize template$<$class T , class S , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+same$<$ std\+::decay\+\_\+t$<$ T $>$, std\+::decay\+\_\+t$<$ S $>$ $>$\+::value \&\&!std\+::is\+\_\+arithmetic$<$ std\+::decay\+\_\+t$<$ T $>$ $>$\+::value $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_a839a72c59a888ed89d3efe38897cc376}{multiply\+\_\+via\+\_\+traits} (T \&\&lhs, S \&\&rhs)
\item 
{\footnotesize template$<$class T , class S , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+arithmetic$<$ T $>$\+::value \&\&std\+::is\+\_\+arithmetic$<$ S $>$\+::value $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_a95f9f46143d0a53a378f776e300c3520}{multiply\+\_\+via\+\_\+traits} (T lhs, S rhs)
\item 
{\footnotesize template$<$class T , class S , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+arithmetic$<$ T $>$\+::value $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !std\+::is\+\_\+arithmetic$<$ std\+::decay\+\_\+t$<$ S $>$ $>$\+::value $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_a780ef12ebddaa8e729d8629d24ae76c5}{multiply\+\_\+via\+\_\+traits} (T lhs, S \&\&rhs)
\item 
{\footnotesize template$<$class T , class S , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+arithmetic$<$ S $>$\+::value $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !std\+::is\+\_\+arithmetic$<$ std\+::decay\+\_\+t$<$ T $>$ $>$\+::value $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_af9f50220300eacbd554ec4b48373535b}{multiply\+\_\+via\+\_\+traits} (T \&\&lhs, S rhs)
\item 
{\footnotesize template$<$class T , class S , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+same$<$ std\+::decay\+\_\+t$<$ T $>$, std\+::decay\+\_\+t$<$ S $>$ $>$\+::value \&\&!std\+::is\+\_\+arithmetic$<$ std\+::decay\+\_\+t$<$ T $>$ $>$\+::value $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_a1aa47c6870754d5d74100568cd3ef532}{add\+\_\+via\+\_\+traits} (T \&\&lhs, S \&\&rhs)
\item 
{\footnotesize template$<$class T , class S , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+arithmetic$<$ T $>$\+::value \&\&std\+::is\+\_\+arithmetic$<$ S $>$\+::value $>$ $\ast$  = nullptr$>$ }\\auto \hyperlink{namespaceFunG_a6cbaa3b1b61e5834b38db5c831e3c25e}{add\+\_\+via\+\_\+traits} (T lhs, S rhs)
\item 
{\footnotesize template$<$class Matrix , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Constant\+Size$<$\+Matrix$>$() $\vert$$\vert$ is\+\_\+arithmetic$<$\+Matrix$>$\+::value$>$$>$ }\\Matrix \hyperlink{namespaceFunG_a649b4470d6def401959bfea3a368c48c}{zero} ()
\begin{DoxyCompactList}\small\item\em Requires that a specialization of struct \hyperlink{structFunG_1_1Zero}{Zero} exists for Matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Matrix , class  = std\+::enable\+\_\+if\+\_\+t$<$!\+Checks\+::is\+Constant\+Size$<$\+Matrix$>$() \&\& !is\+\_\+arithmetic$<$\+Matrix$>$\+::value$>$$>$ }\\constexpr Matrix \hyperlink{namespaceFunG_ae633433339ba30207aa526e54e3924b4}{zero} (int rows, int cols)
\begin{DoxyCompactList}\small\item\em Requires that a specialization of struct \hyperlink{structFunG_1_1Zero}{Zero} exists for Matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$int id, class T $>$ }\\\hyperlink{structFunG_1_1Variable}{Variable}$<$ T, id $>$ \hyperlink{namespaceFunG_a2ead025b35a8cdf3ac8c170524ab61c0}{variable} (const T \&t)
\begin{DoxyCompactList}\small\item\em Generate variable from input type. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Main namespace of the FunG library. 

\begin{DoxySeeAlso}{See also}
\hyperlink{group__MathematicalOperationsGroup}{Mathematical Operations} 

\hyperlink{group__CMathGroup}{Common Mathematical Functions} 

\hyperlink{group__LinearAlgebraGroup}{Linear Algebra} 
\end{DoxySeeAlso}


\subsection{Typedef Documentation}
\index{FunG@{FunG}!decay\+\_\+t@{decay\+\_\+t}}
\index{decay\+\_\+t@{decay\+\_\+t}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{decay\+\_\+t}{decay_t}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class F $>$ using {\bf Fun\+G\+::decay\+\_\+t} = typedef typename {\bf Decay}$<$ std\+::decay\+\_\+t$<$ F $>$ $>$\+::type}\hypertarget{namespaceFunG_a7ff91644f18a190ac3d4fc9e970ebe2e}{}\label{namespaceFunG_a7ff91644f18a190ac3d4fc9e970ebe2e}


\hyperlink{namespaceFunG_1_1Access}{Access} underlying type (if it is hidden by expression templates). 

\index{FunG@{FunG}!remove\+\_\+reference\+\_\+t@{remove\+\_\+reference\+\_\+t}}
\index{remove\+\_\+reference\+\_\+t@{remove\+\_\+reference\+\_\+t}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{remove\+\_\+reference\+\_\+t}{remove_reference_t}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class F $>$ using {\bf Fun\+G\+::remove\+\_\+reference\+\_\+t} = typedef typename {\bf Decay}$<$ std\+::remove\+\_\+reference\+\_\+t$<$ F $>$ $>$\+::type}\hypertarget{namespaceFunG_a40f6d0896c1e3837d442d39418a4f609}{}\label{namespaceFunG_a40f6d0896c1e3837d442d39418a4f609}


\hyperlink{namespaceFunG_1_1Access}{Access} underlying type (if it is hidden by expression templates). 

\index{FunG@{FunG}!Variable\+\_\+t@{Variable\+\_\+t}}
\index{Variable\+\_\+t@{Variable\+\_\+t}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{Variable\+\_\+t}{Variable_t}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class F , int id$>$ using {\bf Fun\+G\+::\+Variable\+\_\+t} = typedef typename Variable\+Detail\+::\+Variable\+Type$<$ std\+::decay\+\_\+t$<$ F $>$, id $>$\+::type}\hypertarget{namespaceFunG_a1c6fc5c4c7cd6678b9de8962c14b86b5}{}\label{namespaceFunG_a1c6fc5c4c7cd6678b9de8962c14b86b5}


Get underlying type of variable with index id. 

\index{FunG@{FunG}!void\+\_\+t@{void\+\_\+t}}
\index{void\+\_\+t@{void\+\_\+t}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{void\+\_\+t}{void_t}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class... Types$>$ using {\bf Fun\+G\+::void\+\_\+t} = typedef typename Detail\+::voider$<$Types...$>$\+::type}\hypertarget{namespaceFunG_a0cde667596590eb8d32e4a5ee76ddbb9}{}\label{namespaceFunG_a0cde667596590eb8d32e4a5ee76ddbb9}


Most fascinating type ever. Is void for all input types. 



\subsection{Function Documentation}
\index{FunG@{FunG}!add\+\_\+via\+\_\+traits@{add\+\_\+via\+\_\+traits}}
\index{add\+\_\+via\+\_\+traits@{add\+\_\+via\+\_\+traits}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{add\+\_\+via\+\_\+traits(\+T \&\&lhs, S \&\&rhs)}{add_via_traits(T &&lhs, S &&rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class S , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+same$<$ std\+::decay\+\_\+t$<$ T $>$, std\+::decay\+\_\+t$<$ S $>$ $>$\+::value \&\&!std\+::is\+\_\+arithmetic$<$ std\+::decay\+\_\+t$<$ T $>$ $>$\+::value $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::add\+\_\+via\+\_\+traits (
\begin{DoxyParamCaption}
\item[{T \&\&}]{lhs, }
\item[{S \&\&}]{rhs}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_a1aa47c6870754d5d74100568cd3ef532}{}\label{namespaceFunG_a1aa47c6870754d5d74100568cd3ef532}
\index{FunG@{FunG}!add\+\_\+via\+\_\+traits@{add\+\_\+via\+\_\+traits}}
\index{add\+\_\+via\+\_\+traits@{add\+\_\+via\+\_\+traits}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{add\+\_\+via\+\_\+traits(\+T lhs, S rhs)}{add_via_traits(T lhs, S rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class S , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+arithmetic$<$ T $>$\+::value \&\&std\+::is\+\_\+arithmetic$<$ S $>$\+::value $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::add\+\_\+via\+\_\+traits (
\begin{DoxyParamCaption}
\item[{T}]{lhs, }
\item[{S}]{rhs}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_a6cbaa3b1b61e5834b38db5c831e3c25e}{}\label{namespaceFunG_a6cbaa3b1b61e5834b38db5c831e3c25e}
\index{FunG@{FunG}!add\+Transposed@{add\+Transposed}}
\index{add\+Transposed@{add\+Transposed}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{add\+Transposed(\+Matrix \&\+A)}{addTransposed(Matrix &A)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Matrix , std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Constant\+Size$<$ Matrix $>$()$>$ $\ast$  = nullptr$>$ Matrix Fun\+G\+::add\+Transposed (
\begin{DoxyParamCaption}
\item[{Matrix \&}]{A}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_a0211d0d26c669d56b5113fd2292902e5}{}\label{namespaceFunG_a0211d0d26c669d56b5113fd2292902e5}


Overwrites $A$ with $A+A^T$. 

\begin{DoxyReturn}{Returns}
$A+A^T$ 
\end{DoxyReturn}
\index{FunG@{FunG}!at@{at}}
\index{at@{at}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{at(\+Matrix \&\&\+A, Index i, Index j)}{at(Matrix &&A, Index i, Index j)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Matrix , class Index , class  = std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+integral$<$\+Index$>$\+::value $>$$>$ decltype(auto) {\bf F\+U\+N\+G\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE} Fun\+G\+::at (
\begin{DoxyParamCaption}
\item[{Matrix \&\&}]{A, }
\item[{Index}]{i, }
\item[{Index}]{j}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_aae631e6149505bdfc0b1c6162b370c7f}{}\label{namespaceFunG_aae631e6149505bdfc0b1c6162b370c7f}


\hyperlink{namespaceFunG_1_1Access}{Access} matrix entry $A_{ij}$. 

\index{FunG@{FunG}!at@{at}}
\index{at@{at}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{at(\+Vector \&\&v, Index i)}{at(Vector &&v, Index i)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Vector , class Index , class  = std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+integral$<$\+Index$>$\+::value $>$$>$ decltype(auto) {\bf F\+U\+N\+G\+\_\+\+A\+L\+W\+A\+Y\+S\+\_\+\+I\+N\+L\+I\+NE} Fun\+G\+::at (
\begin{DoxyParamCaption}
\item[{Vector \&\&}]{v, }
\item[{Index}]{i}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_aa40271c9228c5ccee8a4973f27918630}{}\label{namespaceFunG_aa40271c9228c5ccee8a4973f27918630}


\hyperlink{namespaceFunG_1_1Access}{Access} vector entry. 

\index{FunG@{FunG}!constant@{constant}}
\index{constant@{constant}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{constant(\+Arg x)}{constant(Arg x)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Arg $>$ constexpr auto Fun\+G\+::constant (
\begin{DoxyParamCaption}
\item[{Arg}]{x}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_a939d13d36c194b402715f12a28147cdc}{}\label{namespaceFunG_a939d13d36c194b402715f12a28147cdc}


Wrap a constant. 

\begin{DoxyReturn}{Returns}
Constant$<$\+Arg$>$(x) 
\end{DoxyReturn}
\index{FunG@{FunG}!const\+Ref@{const\+Ref}}
\index{const\+Ref@{const\+Ref}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{const\+Ref(const Arg \&x)}{constRef(const Arg &x)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Arg $>$ auto Fun\+G\+::const\+Ref (
\begin{DoxyParamCaption}
\item[{const Arg \&}]{x}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_abcfb38c2e995436816ea884803302f2d}{}\label{namespaceFunG_abcfb38c2e995436816ea884803302f2d}


Generate a constant function that stores its argument as constant reference. 

This admits to use variable constant arguments, i.\+e. parameters that we want to study. \index{FunG@{FunG}!dot@{dot}}
\index{dot@{dot}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{dot(\+F \&\&f, G \&\&g)}{dot(F &&f, G &&g)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class F , class G , std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ F $>$ $>$()$\vert$$\vert$\+Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ G $>$ $>$() $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::dot (
\begin{DoxyParamCaption}
\item[{F \&\&}]{f, }
\item[{G \&\&}]{g}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_ac73eb907f3d29a9ea60513a43c658270}{}\label{namespaceFunG_ac73eb907f3d29a9ea60513a43c658270}


overload of \char`\"{}dot\char`\"{}-\/function for the generation of functions. 

If the resulting type represents a polynomial of order smaller than two, than you need to wrap it into Finalize to generate missing derivatives. \index{FunG@{FunG}!finalize@{finalize}}
\index{finalize@{finalize}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{finalize(\+F \&\&f)}{finalize(F &&f)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class F $>$ auto Fun\+G\+::finalize (
\begin{DoxyParamCaption}
\item[{F \&\&}]{f}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_ac59f2ececc3cd451860776320a4a93d5}{}\label{namespaceFunG_ac59f2ececc3cd451860776320a4a93d5}


Finish function definition. 

Adds the definition of possibly undefined vanishing higher order derivatives. If the template class \hyperlink{structFunG_1_1Variable}{Variable} is not used, then no ids must be provided for the update-\/function and derivatives. \index{FunG@{FunG}!heat\+Model@{heat\+Model}}
\index{heat\+Model@{heat\+Model}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{heat\+Model(double c, double d, Scalar u, const Vector \&du)}{heatModel(double c, double d, Scalar u, const Vector &du)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Scalar , class Vector $>$ auto Fun\+G\+::heat\+Model (
\begin{DoxyParamCaption}
\item[{double}]{c, }
\item[{double}]{d, }
\item[{Scalar}]{u, }
\item[{const Vector \&}]{du}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_aab17a1468e61f58564333b3fcd7900d6}{}\label{namespaceFunG_aab17a1468e61f58564333b3fcd7900d6}


Weak model for nonlinear heat transfer $ (c+du^2)\nabla u $. 


\begin{DoxyParams}{Parameters}
{\em c} & weighing of linearity \\
\hline
{\em d} & weighing of nonlinearity \\
\hline
{\em u} & heat \\
\hline
{\em du} & heat gradient \\
\hline
\end{DoxyParams}
\index{FunG@{FunG}!identity@{identity}}
\index{identity@{identity}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{identity(const Arg \&x)}{identity(const Arg &x)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Arg $>$ auto Fun\+G\+::identity (
\begin{DoxyParamCaption}
\item[{const Arg \&}]{x}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_a165e879e76d3a2a8906938f3658445ce}{}\label{namespaceFunG_a165e879e76d3a2a8906938f3658445ce}


Construct Identity$<$\+Arg$>$(x). 

\index{FunG@{FunG}!multiply\+\_\+via\+\_\+traits@{multiply\+\_\+via\+\_\+traits}}
\index{multiply\+\_\+via\+\_\+traits@{multiply\+\_\+via\+\_\+traits}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{multiply\+\_\+via\+\_\+traits(\+T \&\&lhs, S \&\&rhs)}{multiply_via_traits(T &&lhs, S &&rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class S , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+same$<$ std\+::decay\+\_\+t$<$ T $>$, std\+::decay\+\_\+t$<$ S $>$ $>$\+::value \&\&!std\+::is\+\_\+arithmetic$<$ std\+::decay\+\_\+t$<$ T $>$ $>$\+::value $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::multiply\+\_\+via\+\_\+traits (
\begin{DoxyParamCaption}
\item[{T \&\&}]{lhs, }
\item[{S \&\&}]{rhs}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_a839a72c59a888ed89d3efe38897cc376}{}\label{namespaceFunG_a839a72c59a888ed89d3efe38897cc376}
\index{FunG@{FunG}!multiply\+\_\+via\+\_\+traits@{multiply\+\_\+via\+\_\+traits}}
\index{multiply\+\_\+via\+\_\+traits@{multiply\+\_\+via\+\_\+traits}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{multiply\+\_\+via\+\_\+traits(\+T lhs, S rhs)}{multiply_via_traits(T lhs, S rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class S , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+arithmetic$<$ T $>$\+::value \&\&std\+::is\+\_\+arithmetic$<$ S $>$\+::value $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::multiply\+\_\+via\+\_\+traits (
\begin{DoxyParamCaption}
\item[{T}]{lhs, }
\item[{S}]{rhs}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_a95f9f46143d0a53a378f776e300c3520}{}\label{namespaceFunG_a95f9f46143d0a53a378f776e300c3520}
\index{FunG@{FunG}!multiply\+\_\+via\+\_\+traits@{multiply\+\_\+via\+\_\+traits}}
\index{multiply\+\_\+via\+\_\+traits@{multiply\+\_\+via\+\_\+traits}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{multiply\+\_\+via\+\_\+traits(\+T lhs, S \&\&rhs)}{multiply_via_traits(T lhs, S &&rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class S , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+arithmetic$<$ T $>$\+::value $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !std\+::is\+\_\+arithmetic$<$ std\+::decay\+\_\+t$<$ S $>$ $>$\+::value $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::multiply\+\_\+via\+\_\+traits (
\begin{DoxyParamCaption}
\item[{T}]{lhs, }
\item[{S \&\&}]{rhs}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_a780ef12ebddaa8e729d8629d24ae76c5}{}\label{namespaceFunG_a780ef12ebddaa8e729d8629d24ae76c5}
\index{FunG@{FunG}!multiply\+\_\+via\+\_\+traits@{multiply\+\_\+via\+\_\+traits}}
\index{multiply\+\_\+via\+\_\+traits@{multiply\+\_\+via\+\_\+traits}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{multiply\+\_\+via\+\_\+traits(\+T \&\&lhs, S rhs)}{multiply_via_traits(T &&lhs, S rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T , class S , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+arithmetic$<$ S $>$\+::value $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !std\+::is\+\_\+arithmetic$<$ std\+::decay\+\_\+t$<$ T $>$ $>$\+::value $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::multiply\+\_\+via\+\_\+traits (
\begin{DoxyParamCaption}
\item[{T \&\&}]{lhs, }
\item[{S}]{rhs}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_af9f50220300eacbd554ec4b48373535b}{}\label{namespaceFunG_af9f50220300eacbd554ec4b48373535b}
\index{FunG@{FunG}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Dune\+::\+Field\+Vector$<$ Scalar, n $>$ \&a, const Dune\+::\+Field\+Vector$<$ Other\+Scalar, n $>$ \&b)}{operator*(const Dune::FieldVector< Scalar, n > &a, const Dune::FieldVector< OtherScalar, n > &b)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Scalar , class Other\+Scalar , int n, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::\+Has\+::\+Free\+::multiplication$<$ Dune\+::\+Field\+Vector$<$ Scalar, n $>$, Dune\+::\+Field\+Vector$<$ Other\+Scalar, n $>$ $>$() $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const Dune\+::\+Field\+Vector$<$ Scalar, n $>$ \&}]{a, }
\item[{const Dune\+::\+Field\+Vector$<$ Other\+Scalar, n $>$ \&}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_a5e258023361844926f485229c62a733b}{}\label{namespaceFunG_a5e258023361844926f485229c62a733b}


Computation of the l2 scalar product for Dune\+::\+Field\+Vector. 

\index{FunG@{FunG}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Dune\+::\+Field\+Matrix$<$ Scalar, n, m $>$ \&\+A, const Dune\+::\+Field\+Vector$<$ Other\+Scalar, m $>$ \&x)}{operator*(const Dune::FieldMatrix< Scalar, n, m > &A, const Dune::FieldVector< OtherScalar, m > &x)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Scalar , class Other\+Scalar , int n, int m, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::\+Has\+::\+Free\+::multiplication$<$ Dune\+::\+Field\+Matrix$<$ Scalar, n, m $>$, Dune\+::\+Field\+Vector$<$ Other\+Scalar, m $>$ $>$() $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const Dune\+::\+Field\+Matrix$<$ Scalar, n, m $>$ \&}]{A, }
\item[{const Dune\+::\+Field\+Vector$<$ Other\+Scalar, m $>$ \&}]{x}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_abadb8da34a5abc3dde0107231ab91c6f}{}\label{namespaceFunG_abadb8da34a5abc3dde0107231ab91c6f}


Define matrix-\/vector multiplication for Dune\+::\+Field\+Matrix and Dune\+::\+Field\+Vector, i.\+e. compute $y=Ax$. 

\index{FunG@{FunG}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Dune\+::\+Field\+Vector$<$ Other\+Scalar, n $>$ \&x, const Dune\+::\+Field\+Matrix$<$ Scalar, n, m $>$ \&\+A)}{operator*(const Dune::FieldVector< OtherScalar, n > &x, const Dune::FieldMatrix< Scalar, n, m > &A)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Scalar , class Other\+Scalar , int n, int m, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::\+Has\+::\+Free\+::multiplication$<$ Dune\+::\+Field\+Vector$<$ Other\+Scalar, n $>$, Dune\+::\+Field\+Matrix$<$ Scalar, n, m $>$ $>$() $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const Dune\+::\+Field\+Vector$<$ Other\+Scalar, n $>$ \&}]{x, }
\item[{const Dune\+::\+Field\+Matrix$<$ Scalar, n, m $>$ \&}]{A}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_a19a9d7b55b56f5101560034413a1dbfe}{}\label{namespaceFunG_a19a9d7b55b56f5101560034413a1dbfe}


Define vector-\/matrix multiplication for Dune\+::\+Field\+Matrix and Dune\+::\+Field\+Vector, i.\+e. compute $x^T A = y^T$ resp. $y=A^T x$. 

\index{FunG@{FunG}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{operator$\ast$(\+Scalar\+Arg a, Arg x)}{operator*(ScalarArg a, Arg x)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Arg , class Scalar\+Arg , std\+::enable\+\_\+if\+\_\+t$<$ is\+\_\+arithmetic$<$ Scalar\+Arg $>$\+::value $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::is\+Function$<$ Arg $>$()\&\&!is\+\_\+arithmetic$<$ Arg $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::\+Has\+::\+Free\+::multiplication$<$ Scalar\+Arg, Arg $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::\+Has\+::\+Mem\+Op\+::in\+Place\+Multiplication$<$ Arg, Scalar\+Arg $>$() $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{Scalar\+Arg}]{a, }
\item[{Arg}]{x}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_ac71b238827eda3b6518c39e49447bdeb}{}\label{namespaceFunG_ac71b238827eda3b6518c39e49447bdeb}


Defines operator$\ast$ for multiplication with arithmetic types from the left if undefined and in-\/place multiplication (operator$\ast$=()) is supported. 

\index{FunG@{FunG}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{operator$\ast$(\+Arg x, Scalar\+Arg a)}{operator*(Arg x, ScalarArg a)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Arg , class Scalar\+Arg , std\+::enable\+\_\+if\+\_\+t$<$ is\+\_\+arithmetic$<$ Scalar\+Arg $>$\+::value $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::is\+Function$<$ Arg $>$()\&\&!is\+\_\+arithmetic$<$ Arg $>$\+::value $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::\+Has\+::\+Free\+::multiplication$<$ Scalar\+Arg, Arg $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::\+Has\+::\+Mem\+Op\+::in\+Place\+Multiplication$<$ Arg, Scalar\+Arg $>$() $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{Arg}]{x, }
\item[{Scalar\+Arg}]{a}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_a49623beb215912a02388a11cc18f15fe}{}\label{namespaceFunG_a49623beb215912a02388a11cc18f15fe}


Defines operator$\ast$ for multiplication with arithmetic types from the right if undefined and in-\/place multiplication (operator$\ast$=()) is supported. 

\index{FunG@{FunG}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{operator$\ast$(\+Arg1 x, const Arg2 \&y)}{operator*(Arg1 x, const Arg2 &y)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Arg1 , class Arg2 , std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::is\+Function$<$ Arg1 $>$()\&\&!\+Checks\+::is\+Function$<$ Arg2 $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !is\+\_\+arithmetic$<$ Arg1 $>$()\&\&!is\+\_\+arithmetic$<$ Arg2 $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::\+Has\+::\+Free\+::multiplication$<$ Arg1, Arg2 $>$()\&\&\+Checks\+::\+Has\+::\+Mem\+Op\+::in\+Place\+Multiplication$<$ Arg1, Arg2 $>$() $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{Arg1}]{x, }
\item[{const Arg2 \&}]{y}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_ad023f2d2273af693f2b4ebceeb296dc8}{}\label{namespaceFunG_ad023f2d2273af693f2b4ebceeb296dc8}


Defines operator$\ast$ for multiplication of non-\/arithmetic types if undefined and in-\/place multiplication (operator$\ast$=()) is supported. 

Defines operator$\ast$ for multiplication of non-\/arithmetic types if undefined and in-\/place multiplication is provided in terms of the member function \hyperlink{namespaceFunG_1_1Checks_1_1Has_1_1MemFn_adeb3d401c6464514644930596c3a4ccc}{rightmultiplyany()} (such as for Dune\+::\+Field\+Matrix). \index{FunG@{FunG}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{operator$\ast$(\+F \&\&f, G \&\&g)}{operator*(F &&f, G &&g)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class F , class G , std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ F $>$ $>$()$\vert$$\vert$\+Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ G $>$ $>$() $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{F \&\&}]{f, }
\item[{G \&\&}]{g}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_a267562e725c73ece1c1d057b5f29511f}{}\label{namespaceFunG_a267562e725c73ece1c1d057b5f29511f}


overload of \char`\"{}$\ast$\char`\"{}-\/operator for the generation of functions. 

If the resulting type represents a polynomial of order smaller than two, than you need to wrap it into Finalize to generate missing derivatives. \index{FunG@{FunG}!operator+@{operator+}}
\index{operator+@{operator+}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{operator+(\+Arg x, const Arg \&y)}{operator+(Arg x, const Arg &y)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Arg , std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::is\+Function$<$ Arg $>$()\&\&!is\+\_\+arithmetic$<$ Arg $>$() $>$ $\ast$  = nullptr, std\+::enable\+\_\+if\+\_\+t$<$ !\+Checks\+::\+Has\+::\+Free\+::summation$<$ Arg $>$()\&\&\+Checks\+::\+Has\+::\+Mem\+Op\+::in\+Place\+Summation$<$ Arg $>$() $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::operator+ (
\begin{DoxyParamCaption}
\item[{Arg}]{x, }
\item[{const Arg \&}]{y}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_a063d3e8c19dbea3ee1396736fecb64e1}{}\label{namespaceFunG_a063d3e8c19dbea3ee1396736fecb64e1}


Defines operator+ if not yet defined and in-\/place summation (operator+=()) is supported. 

\index{FunG@{FunG}!operator+@{operator+}}
\index{operator+@{operator+}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{operator+(\+F \&\&f, G \&\&g)}{operator+(F &&f, G &&g)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class F , class G , std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ F $>$ $>$()$\vert$$\vert$\+Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ G $>$ $>$() $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::operator+ (
\begin{DoxyParamCaption}
\item[{F \&\&}]{f, }
\item[{G \&\&}]{g}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_a24bb5d609b022030afda2d8589cf5509}{}\label{namespaceFunG_a24bb5d609b022030afda2d8589cf5509}


overload of \char`\"{}+\char`\"{}-\/operator for the generation of functions. 

If the resulting type represents a polynomial of order smaller than two, than you need to wrap it into Finalize to generate missing derivatives. \index{FunG@{FunG}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{operator-\/(\+F \&\&f, G \&\&g)}{operator-(F &&f, G &&g)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class F , class G , std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ F $>$ $>$()$\vert$$\vert$\+Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ G $>$ $>$() $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{F \&\&}]{f, }
\item[{G \&\&}]{g}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_a3af04c2ef5c1b206feb75fffd298cbbf}{}\label{namespaceFunG_a3af04c2ef5c1b206feb75fffd298cbbf}


overload of \char`\"{}-\/\char`\"{}-\/operator for the generation of functions. 

If the resulting type represents a polynomial of order smaller than two, than you need to wrap it into Finalize to generate missing derivatives. \index{FunG@{FunG}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{operator$<$$<$(\+F \&\&f, G \&\&g)}{operator<<(F &&f, G &&g)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class F , class G , std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ F $>$ $>$()\&\&\+Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ G $>$ $>$() $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{F \&\&}]{f, }
\item[{G \&\&}]{g}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_a65436d4494e99629b0177d0df7634a6b}{}\label{namespaceFunG_a65436d4494e99629b0177d0df7634a6b}


overload of \char`\"{}$<$$<$\char`\"{}-\/operator for chaining functions $f$ and $g$ to $ f \circ g $. 

If the resulting type represents a polynomial of order smaller than two, than you need to wrap it into Finalize to generate missing derivatives. \index{FunG@{FunG}!operator$^\wedge$@{operator$^\wedge$}}
\index{operator$^\wedge$@{operator$^\wedge$}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{operator$^\wedge$(\+F \&\&f, int k)}{operator^(F &&f, int k)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class F , std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ F $>$ $>$() $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::operator$^\wedge$ (
\begin{DoxyParamCaption}
\item[{F \&\&}]{f, }
\item[{int}]{k}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_a94273e3ea80324e591bb98ae3c051221}{}\label{namespaceFunG_a94273e3ea80324e591bb98ae3c051221}


overload of \char`\"{}$^\wedge$\char`\"{}-\/operator for the generation of functions. 

If the resulting type represents a polynomial of order smaller than two, than you need to wrap it into Finalize to generate missing derivatives. \index{FunG@{FunG}!squared@{squared}}
\index{squared@{squared}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{squared(\+F \&\&f)}{squared(F &&f)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class F , std\+::enable\+\_\+if\+\_\+t$<$ Checks\+::is\+Function$<$ std\+::decay\+\_\+t$<$ F $>$ $>$() $>$ $\ast$  = nullptr$>$ auto Fun\+G\+::squared (
\begin{DoxyParamCaption}
\item[{F \&\&}]{f}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_ac4ffc0754104af6ddf114e154251db78}{}\label{namespaceFunG_ac4ffc0754104af6ddf114e154251db78}


Generate squared function. 

If the resulting type represents a polynomial of order smaller than two, than you need to wrap it into Finalize to generate missing derivatives. \index{FunG@{FunG}!update\+\_\+if\+\_\+present@{update\+\_\+if\+\_\+present}}
\index{update\+\_\+if\+\_\+present@{update\+\_\+if\+\_\+present}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{update\+\_\+if\+\_\+present(\+F \&\&, Arg \&\&)}{update_if_present(F &&, Arg &&)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class F , class Arg , std\+::enable\+\_\+if\+\_\+t$<$!\+Detail\+::\+Has\+Update\+Without\+Index$<$ F, Arg $>$\+::value $>$ $\ast$  = nullptr$>$ void Fun\+G\+::update\+\_\+if\+\_\+present (
\begin{DoxyParamCaption}
\item[{F \&\&}]{f, }
\item[{Arg \&\&}]{x}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_a3b9d2e5d07b30c2ee26703b33e9adb9e}{}\label{namespaceFunG_a3b9d2e5d07b30c2ee26703b33e9adb9e}
\index{FunG@{FunG}!update\+\_\+if\+\_\+present@{update\+\_\+if\+\_\+present}}
\index{update\+\_\+if\+\_\+present@{update\+\_\+if\+\_\+present}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{update\+\_\+if\+\_\+present(\+F \&\&, Arg \&\&)}{update_if_present(F &&, Arg &&)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$int id, class F , class Arg , std\+::enable\+\_\+if\+\_\+t$<$!\+Detail\+::\+Has\+Update\+With\+Index$<$ F, Arg, id $>$\+::value $>$ $\ast$  = nullptr$>$ void Fun\+G\+::update\+\_\+if\+\_\+present (
\begin{DoxyParamCaption}
\item[{F \&\&}]{f, }
\item[{Arg \&\&}]{x}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_aed5ddbef97c98202e818bca2b74c75d2}{}\label{namespaceFunG_aed5ddbef97c98202e818bca2b74c75d2}
\index{FunG@{FunG}!variable@{variable}}
\index{variable@{variable}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{variable(const T \&t)}{variable(const T &t)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$int id, class T $>$ {\bf Variable}$<$ T, id $>$ Fun\+G\+::variable (
\begin{DoxyParamCaption}
\item[{const T \&}]{t}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_a2ead025b35a8cdf3ac8c170524ab61c0}{}\label{namespaceFunG_a2ead025b35a8cdf3ac8c170524ab61c0}


Generate variable from input type. 

\index{FunG@{FunG}!volumetric\+Hartmann\+Neff@{volumetric\+Hartmann\+Neff}}
\index{volumetric\+Hartmann\+Neff@{volumetric\+Hartmann\+Neff}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{volumetric\+Hartmann\+Neff(double d0, double d1, const Matrix \&\+A)}{volumetricHartmannNeff(double d0, double d1, const Matrix &A)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Matrix $>$ auto Fun\+G\+::volumetric\+Hartmann\+Neff (
\begin{DoxyParamCaption}
\item[{double}]{d0, }
\item[{double}]{d1, }
\item[{const Matrix \&}]{A}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_adf4be5df85ea9df10cc9e11c11aaeb7b}{}\label{namespaceFunG_adf4be5df85ea9df10cc9e11c11aaeb7b}


Create the volumetric penalty function $ d_0 j^5 + d_1 j^{-5},\ j=\det(A) $. 

\index{FunG@{FunG}!volumetric\+Penalty@{volumetric\+Penalty}}
\index{volumetric\+Penalty@{volumetric\+Penalty}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{volumetric\+Penalty(double d0, double d1, const Matrix \&\+A)}{volumetricPenalty(double d0, double d1, const Matrix &A)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Inflation , class Compression , class Matrix $>$ auto Fun\+G\+::volumetric\+Penalty (
\begin{DoxyParamCaption}
\item[{double}]{d0, }
\item[{double}]{d1, }
\item[{const Matrix \&}]{A}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_ad26faeb264bb4b1cd7e70f3811c366c8}{}\label{namespaceFunG_ad26faeb264bb4b1cd7e70f3811c366c8}


Create volumetric penalty function composed of a penalty for inflation and one for compression. 

\index{FunG@{FunG}!volumetric\+Quad\+And\+Log@{volumetric\+Quad\+And\+Log}}
\index{volumetric\+Quad\+And\+Log@{volumetric\+Quad\+And\+Log}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{volumetric\+Quad\+And\+Log(double d0, double d1, const Matrix \&\+A)}{volumetricQuadAndLog(double d0, double d1, const Matrix &A)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Matrix $>$ auto Fun\+G\+::volumetric\+Quad\+And\+Log (
\begin{DoxyParamCaption}
\item[{double}]{d0, }
\item[{double}]{d1, }
\item[{const Matrix \&}]{A}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_aaf30b9c36ed86e01b94f6b7c1d95cae8}{}\label{namespaceFunG_aaf30b9c36ed86e01b94f6b7c1d95cae8}


Create the volumetric penalty function $ d_0 j^2 + d_1 \log(j),\ j=\det(A) $. 

\index{FunG@{FunG}!yield\+Surface@{yield\+Surface}}
\index{yield\+Surface@{yield\+Surface}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{yield\+Surface(double beta, double offset, Matrix sigma=\+Linear\+Algebra\+::unit\+Matrix$<$ Matrix $>$())}{yieldSurface(double beta, double offset, Matrix sigma=LinearAlgebra::unitMatrix< Matrix >())}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Matrix $>$ auto Fun\+G\+::yield\+Surface (
\begin{DoxyParamCaption}
\item[{double}]{beta, }
\item[{double}]{offset, }
\item[{Matrix}]{sigma = {\ttfamily {\bf Linear\+Algebra\+::unit\+Matrix}$<$Matrix$>$()}}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_a4784211358c877f05ad9426850303273}{}\label{namespaceFunG_a4784211358c877f05ad9426850303273}


Yield surface $ \frac{\beta}{3}\iota_1(\sigma) + J_2(\sigma)-offset $, where $\iota_1$ is the first principal and $J_2$ is the second deviatoric invariant. 

\index{FunG@{FunG}!zero@{zero}}
\index{zero@{zero}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{zero()}{zero()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Matrix , class  = std\+::enable\+\_\+if\+\_\+t$<$\+Checks\+::is\+Constant\+Size$<$\+Matrix$>$() $\vert$$\vert$ is\+\_\+arithmetic$<$\+Matrix$>$\+::value$>$$>$ Matrix Fun\+G\+::zero (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_a649b4470d6def401959bfea3a368c48c}{}\label{namespaceFunG_a649b4470d6def401959bfea3a368c48c}


Requires that a specialization of struct \hyperlink{structFunG_1_1Zero}{Zero} exists for Matrix. 

\begin{DoxyReturn}{Returns}
constant size zero matrix 
\end{DoxyReturn}
\index{FunG@{FunG}!zero@{zero}}
\index{zero@{zero}!FunG@{FunG}}
\subsubsection[{\texorpdfstring{zero(int rows, int cols)}{zero(int rows, int cols)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Matrix , class  = std\+::enable\+\_\+if\+\_\+t$<$!\+Checks\+::is\+Constant\+Size$<$\+Matrix$>$() \&\& !is\+\_\+arithmetic$<$\+Matrix$>$\+::value$>$$>$ constexpr Matrix Fun\+G\+::zero (
\begin{DoxyParamCaption}
\item[{int}]{rows, }
\item[{int}]{cols}
\end{DoxyParamCaption}
)}\hypertarget{namespaceFunG_ae633433339ba30207aa526e54e3924b4}{}\label{namespaceFunG_ae633433339ba30207aa526e54e3924b4}


Requires that a specialization of struct \hyperlink{structFunG_1_1Zero}{Zero} exists for Matrix. 

\begin{DoxyReturn}{Returns}
dynamic size zero matrix 
\end{DoxyReturn}
