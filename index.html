<!DOCTYPE html>
<html>

  <head>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript"
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <!--Load the AJAX API-->
    <script type="text/javascript" src="https://www.google.com/jsapi"></script>
    <script type="text/javascript">

      // Load the Visualization API and the piechart package.
      google.load('visualization', '1.0', {'packages':['corechart','columnchart']});

      // Set a callback to run when the Google Visualization API is loaded.
      google.setOnLoadCallback(drawChart);

      // Callback that creates and populates a data table,
      // instantiates the pie chart, passes in the data and
      // draws it.
      function drawChart() {

        // Create the data table.
        var data1 = google.visualization.arrayToDataTable([
          ['Library', 'time/s', { role: 'style' }],
          ['FADBAD++', 0.575, 'blue'],
          ['SACADO', 0.542, 'blue'],
          ['FunG', 0.517, 'orange'],
          ['Manual', 0.507, 'gray']
        ]);
        
        var data2 = google.visualization.arrayToDataTable([
          ['Library', 'time/s', { role: 'style' }],
          ['FADBAD++', 1.412, 'blue'],
          ['FunG', 1.364, 'orange'],
          ['Manual', 1.325, 'gray']
        ]);

        var data3 = google.visualization.arrayToDataTable([
          ['Library', 'time/s', { role: 'style' }],
          ['FADBAD++', 0.581, 'blue'],
          ['SACADO', 0.586, 'blue'],
          ['FunG', 0.499, 'orange'],
          ['Manual', 0.475, 'gray']
        ]);

        var data4 = google.visualization.arrayToDataTable([
          ['Function','Armadillo','DUNE','Eigen'],
          ['update', 2.587   , 2.512    , 2.159],
          ['d0'    , 0.000071, 0.000040 , 0.000064],
          ['d1'    , 0.593   , 0.601    , 0.275],
          ['d2'    , 3.332   , 3.404    , 2.234],
          ['d3'    , 19.227  , 15.852   , 12.026]
        ]);

        var data5 = google.visualization.arrayToDataTable([
          ['Function','Armadillo','DUNE','Eigen'],
          ['update', 2.982   , 2.780    , 2.836],
          ['d0'    , 0.000042, 0.000043 , 0.000049],
          ['d1'    , 1.247   , 0.988    , 1.035],
          ['d2'    , 7.080   , 6.044    , 5.880],
          ['d3'    , 40.810  , 35.792   , 33.987]
        ]);
        
        
        // Set chart options
        var options = {title:'Comparison with different AD implementations',
                       width:500,
                       height:300,
                       legend : { position:"none"},
                       vAxis: {
                         title: 'time/s'
                       }
                      };

         var options_muscle = {title:'Performance for a model of muscle tissue',
                       width:500,
                       height:300,
                       colors: ['blue','orange','gray'],
                       vAxis: {
                         title: 'time/s'
                       }
                      };

                      
        // Instantiate and draw our chart, passing in some options.
        var chart1 = new google.visualization.ColumnChart(document.getElementById('chart1_div'));
        chart1.draw(data1, options);
        var chart2 = new google.visualization.ColumnChart(document.getElementById('chart2_div'));
        chart2.draw(data2, options);
        var chart3 = new google.visualization.ColumnChart(document.getElementById('chart3_div'));
        chart3.draw(data3, options);
        var chart4 = new google.visualization.ColumnChart(document.getElementById('chart4_div'));
        chart4.draw(data4, options_muscle);
        var chart5 = new google.visualization.ColumnChart(document.getElementById('chart5_div'));
        chart5.draw(data5, options_muscle);
        }
        
    </script>

  
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="FunG : A C++-library for the generation of complex functions, including first three derivatives and different variable types.">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>FunG - Function Generation</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/lubkoll/FunG">View on GitHub</a>

          <h1 id="project_title">FunG</h1>
          <h2 id="project_tagline">A C++-library for invariant-based modeling and the generation of complex functions, including first three derivatives and different variable types.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/lubkoll/FunG/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/lubkoll/FunG/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <p><a href="https://travis-ci.org/lubkoll/FunG/builds"><img src="https://travis-ci.org/lubkoll/FunG.svg?branch=master" alt="Build Status"></a>
           <a href="https://coveralls.io/r/lubkoll/FunG?branch=master"><img src="https://coveralls.io/repos/lubkoll/FunG/badge.svg?branch=master" alt="Coverage Status"></a>
<h1>
<a id="FunG" class="anchor" href="#FunG" aria-hidden="true"><span class="octicon octicon-link"></span></a>FunG</h1>

<p>FunG is a C++-library for the generation of complex functions. These can depend on an arbitrary number of variables of different types. Besides the function value the first three, possibly mixed, directional derivatives are provided. The evaluation of function values and derivatives is (almost) as efficient as optimized manual implementations.<br>Possibly modified, principal and mixed invariants, the basic blocks of complex physical models, are provided, as well as some isotropic and anisotropic models from biomechanics.</p>
<p>The name FunG was chosen as a tribute to <a href="https://en.wikipedia.org/wiki/Yuan-Cheng_Fung">Yuan-Cheng Fung</a> and his numerous contributions to the field of biomechanics. State-of-the-art models based on his exponential constitutive relation where the motivation to write this library.</p>

<p>The implementation is similar to forward automatic differentiation (AD) with expression templates. However, here a different perspective is taken. 
<ul>
<li> First, instead of defining a function and computing its derivative a function is defined directly with its derivatives.</li>
<li> Second, the first three (possibly mixed) derivatives are directly available, which is more convenient than repeated application of an automatic differentiation scheme.</li>
<li> Third, C++11-features such as <code>auto</code>, <code>decltype</code> and the incredible <code>void_t</code> (if you don't know about it, <a href="https://www.youtube.com/watch?v=a0FliKwcwXE#t=1750">watch this</a>), easily admit far more general settings, working with rather arbitrary in- and output types. The few requirements are explained in section <a href=#input_requirements>Requirements on arithmetic types</a>.</li></p>
</ul>

<br><h1>
<a id="overview" class="anchor" href="#overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>Overview</h1>

<ul>
  <li><a href=#installation>Installation</a></li>
  <li><a href=#examples>Examples</a></li>
  <li><a href=#input_requirements>Requirements on arithmetic types</a></li>
  <li><a href=#ad_comparison>Comparison with automatic differentation libraries</a></li>
  <li><a href=#optimization_strategies>Optimization strategies</a></li>
  <li><a href=#performance>Performance for a model of muscle tissue</a></li>
  <li><a href=#documentation>Documentation</a></li>
  <li><a href=#publications>Publications and Talks</a></li>
</ul>

<br><h1>
<a id="installation" class="anchor" href="#installation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Installation</h1>

<p>This library is header-only and no installation is required. However, make sure you use a recent compiler such as gcc-x, with x>=4.9.0, with <code>-std=c++1y</code>.</p>

<p>To run the available tests, you can use cmake:
<ul>
 <li>mkdir build</li>
 <li>cd build</li>
 <li>cmake ..</li>
 <li>make</li>
 <li>./unit_tests</li>
 </ul>
</p>


<br><h1>
<a id="examples" class="anchor" href="#examples" aria-hidden="true"><span class="octicon octicon-link"></span></a>Examples</h1>

<p>Usage is illustrated using three different examples. Further examples can be found in fung/tests and fung/examples.</p>

<h3>
<a id="a-simple-example" class="anchor" href="#a-simple-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>A simple example</h3>

<p>We begin with the function \[f(x)=x^{3/2}+\sin(x^{1/2}).\]</p>

<pre><code>#include "fung.hh"

template &lt;class Variable&gt;
auto generateFunction(const Variable&amp; x)
{
  return FunG::finalize_scalar( pow<3>(sqrt(x)) + sin(sqrt(x)) ); 
}
</code></pre>

<p>Usage is as follows:</p>

<pre><code>auto f = generateFunction(variable&lt;0&gt;(1.));

f.template update<0>(1.) //  change function argument

auto value = f(); // or f.d0()
auto firstDerivative  = f.template d1&lt;0&gt;();
auto secondDerivative = f.template d2&lt;0,0&gt;();
auto thirdDerivative  = f.template d3&lt;0,0,0&gt;();
</code></pre>

<p>The call to <code>finalize_scalar</code> is necessary to simplify usage of the generated function. For functions depending only on scalar variables it adds default arguments for the directional derivatives. Without usage is slightly less convenient. This 
is illustrated in the other examples below. </p>

<h3>
<a id="an-example-from-biomechanics" class="anchor" href="#an-example-from-biomechanics" aria-hidden="true"><span class="octicon octicon-link"></span></a>An example from biomechanics</h3>

<p>Now let us generate the function $W:\mathbb{R}^{n,n}\to \mathbb{R}$ with \[W(F)=c_{Cells}(\iota_1-n)+ \frac{k_1}{k_2}\left(\exp(k_2(\kappa\iota_1+(1-3\kappa)\iota_4-1)^2)\right),\] which constitutes an anisotropic model for adipose tissue. In this context the invariants depend on the left Cauchy-Green strain tensor $F^T F$, which can be generated by the (template) function <code>strainTensor</code>. The implementation of this model is</p>

<pre><code>#include "fung.hh"

template &lt;class Mat&gt;
auto generateAdiposeTissue(double cCells, double k1, double k2,
             double kappa, const Matrix&amp; M, const Matrix&amp; F, int n = dim<Mat>())
{
  using namespace FunG;
  using namespace FunG::LinearAlgebra;

  auto aniso = kappa*i1(F) + (1-3*kappa) * i4(F,M) - 1;
  auto materialLaw = cCells*( i1(F) - n ) + (k1/k2) * ( exp(k2*aniso^2) - 1 );

  return materialLaw( strainTensor(F) );
}
</code></pre>

<p>For constant size matrices usage is as follows (assuming that the material parameters, the structural tensor M, the deformation gradient F and perturbations dF0, dF1, dF2 of the latter are given):</p>

<pre><code>auto f = generateAdiposeTissue(cCells,k1,k2,kappa,M,F);

f.update(F) //  change function argument

double value = f(); // or f.d0()
double firstDerivative  = f.d1(dF0);
double secondDerivative = f.d2(dF0,dF1);
double thirdDerivative  = f.d3(dF0,dF1,dF2);
</code></pre>

<p>Observe that the derivatives are DIRECTIONAL derivatives. This approach admits to work with any (reasonable) input types. In the first example, where the input variable was a scalar, the call to finalize_scalar did generate 
suitable default values for the directions. Here this is not admissible. </p>

<p>Take care to not use functions such as 'exp' with built-in arithmetic types, since in this case the corresponding functions from  are called and the resulting value is treated as constant.</p>

<p>Also note that the <code>operator^(int k)</code> is only defined for k=2. For scalar valued functions you may use <code>Pow&lt;dividend,divisor&gt;</code> to represent rational powers.</p>


<h3>
<a id="an-example-with-two-variables" class="anchor" href="#an-example-with-two-variables" aria-hidden="true"><span class="octicon octicon-link"></span></a>An example with two variables</h3>

<p>Consider a function with two variables, a scalar variable x and a matrix valued variable F (which is assumed to be default constructible in this example): \[f(x,F)=\sqrt{x}\mathrm{tr}(F).\]</p>

<pre><code>#include "fung.hh"

template &lt;class Mat&gt;
auto generateFunction()
{
  using namespace Fung;
  using FunG::LinearAlgebra::trace;
  
  auto x = variable&lt;0&gt;(0.);
  auto F = Variable&lt;Mat,1&gt;();

  return finalize( sqrt(x)*trace(F) );
}
</code></pre>

<p>When computing derivatives we now have to specify the variable ids for which the derivative will be computed. The same holds for setting the function values.</p>

<pre><code>auto f = generateFunction&lt;Mat&gt;();

f.template update&lt;0&gt;(x);
f.template update&lt;1&gt;(F);

double value       = f(); // or f.d0()
double df_dx       = f.template d1&lt;0&gt;(dx1);
double df_dF       = f.template d1&lt;1&gt;(dF)
double ddf_dFdx    = f.template d2&lt;1,0&gt;(dF,dx1);
double dddf_dxdxdF = f.template d3&lt;0,0,1&gt;(dx1,dx2,dF);
</code></pre>



<h3>
<a id="nonlinear-heat-example" class="anchor" href="#nonlinear-heat-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>A model for nonlinear heat transfer</h3>

<p>Eventually we consider the weak form of a model of nonlinear heat transfer, given through \[A(u,\nabla u)=(c+du^2)\nabla u.\] In this case $u$ and $ \nabla u$ are represented by 
different types but are associated to the same variable.</p>

<pre><code>#include "fung.hh"

template &lt;class Vec,class Mat&gt;
auto heatModel(double c, double d, const Vec&amp; u0, const Mat&amp; du0)
{
  using namespace Fung;
  auto u = variable&lt;0&gt;(u0);
  auto du = variable&lt;0&gt;(du0);
  auto f = ( c + d*(u^2) ) * du;
  return finalize( f );
}
</code></pre>

<p> To work with such a model it is allowed to pack arguments into tuples. Then usage is as follows (for unknown u, with gradient du, and perturbation v, with gradient dv):</p>

<pre><code>auto f = heatModel(1,1,u,du);

f.template update&lt;0&gt;(std::make_tuple(u,du));

double value       = f(); // or f.d0()
double df_dx       = f.template d1&lt;0&gt;(std::make_tuple(v,dv));
...
</code></pre>


<br><h1>
<a id="input_requirements" class="anchor" href=#input_requirements aria-hidden="true"><span class="octicon octicon-link"></span></a>Requirements on arithmetic types</h1>

One idea that was followed in the development of this library was to make it compatible with common matrix implementations. Currently you can directly use it with  <a href="http://arma.sourceforge.net/">Armadillo</a>, <a href="http://www.dune-project.org">DUNE</a> and <a href="http://eigen.tuxfamily.org">Eigen</a> matrices. 
If you use another matrix library, your own matrix or vector implementation or want to compute with something else, these must satisfy the requirements listed below (see also <a href="html/concepts_8hh.html">concepts.hh</a>). These are statically checked with <code>static_assert</code>. Thus you will get meaningful feedback if your implementation lacks some required feature. However, for most reasonable matrix implementations nothing or almost nothing must be adjusted.</p>


<h3>
<a id="requirements" class="anchor" href=#requirements aria-hidden="true"><span class="octicon octicon-link"></span></a>Requirements</h3>

<ol>
<li><strong>Copyable:</strong><br> T must be <a href="http://en.cppreference.com/w/cpp/concept/CopyConstructible">CopyConstructible</a> and <a href="http://en.cppreference.com/w/cpp/concept/CopyAssignable">CopyAssignable</a>. </li>

<li><strong>Multiplication with arithmetic types:</strong><br> 
Given: 
<ul>
<li>An object t of type T.</li>
<li>An object a of an arithmetic type, such as double or int.</li>
</ul>
At least one of the following expressions must be valid:
<ul>
<li><code>T s = a*t;</code></li>
<li><code> t *= a;</code></li>
</ul></li>

<li><strong>Summation:</strong><br>
Objects t and s of type T must be summable, i.e. at least one of the following expressions must be valid:
<ul>
<li><code>T r = s + t;</code></li>
<li><code>t += s;</code></li>
</ul></li>

<li><strong>Multiplication (for matrix types only):</strong><br>
Compatible matrices t and s must be multipliable, i.e. at least one of the following expressions must be valid:
<ul>
<li><code> auto r = t*s;</code></li>
<li><code> t*=s;</code> (for square matrices)</li>
<li><code> auto r = t.rightmultiplany(s);</code> (for <a href="http://www.dune-project.org">DUNE</a> matrices)</li>
</ul></li>

<li><strong>Access to data:</strong><br>
Access to the entries of a matrix or vector t via at least one of the following expressions:
<ul>
<li><code>auto a = t[1][2];</code> (for matrices) or <code>auto a = t[1];</code> (for vectors).</li>
<li><code>auto a = t(1,2);</code> (for matrices) or <code>auto a = t(1);</code> (for vectors).</li>
</ul></li>

<li><strong>Access to number of rows and columns (matrices and vectors):</strong><br>
<ul>
<li><strong>Fixed size:</strong><br>
A specialization of the template classes <br>
<code>template &lt;class Matrix, class&gt; struct NumberOfRows;</code><br>
and<br>
<code>template &lt;class Matrix, class&gt; struct NumberOfColumns;</code> <br>
must be provided. For the cases that, for some scalar type S and n,m of type unsigned or int, the employed matrix class is of the form
<ul>
<li><code>Matrix&lt;n,m&gt;</code></li>
<li><code>Matrix&lt;S,n,m&gt;</code></li>
</ul>
suitable specializations are available and access to the number of rows and columns is supported without need to do anything. Similar specializations exist for vectors.
</li>

<li><strong>Dynamic size:</strong><br>
Access to the number of rows and columns of an object t must be supported via at least one of the following expressions:
<ul>
<li><code>t.rows()</code> resp. <code>t.cols()</code></li>
<li><code>t.n_rows</code> resp. <code>t.n_cols</code></li>
</ul></li>
</ul>
</li>

</ol>


<h3>
<a id="requirements_optional" class="anchor" href=#requirements aria-hidden="true"><span class="octicon octicon-link"></span></a>Requirements (optional)</h3>

<ol>
<li><strong>Default-constructible:</strong><br>
If T is <a href="http://en.cppreference.com/w/cpp/concept/DefaultConstructible">DefaultConstructible</a> then functions that take arguments of type T also a default constructor, else the default constructor is deleted.
</li>

<li><strong>Construction of the zero matrix:</strong><br>
If you want to use the functions <code>zero&lt;Matrix&gt;()</code> and <code>unitMatrix&lt;Matrix&gt;()</code>, a specialization of<br>
<code>template &lt;class Matrix,class&gt; struct Zero;</code><br>
must be provided. Suitable implementations exist for the cases that a zero matrix can be created by one of the following expressions:
<ul>
<li><code>auto zeroMatrix = Matrix(0.);</code></li>
<li><code>auto zeroMatrix;</code><br>
    <code>zeroMatrix.zeroes();</code></li>
</ul>
</li>

</ol>



<br><h1>
<a id="ad_comparison" class="anchor" href=#ad_comparison aria-hidden="true"><span class="octicon octicon-link"></span></a>Comparison with automatic differentation libraries</h1>

<p>The performance of FunG is demonstrated by several examples comparing it with forward mode automatic differentation of <a href="http://www.fadbad.com">FADBAD++</a> and <a href="https://trilinos.org/packages/sacado">SACADO</a>. 
All examples were compiled with <code>-O2</code> compiler option with gcc-4.9.2. They were run on an ASUS UX32V. All examples were evaluated 10.000.000 times (function value + derivative(s)) with varying arguments.</p>

<h4>A simple example</h4>
<p>Consider $f(x)=x^{3/2}+\sin(\sqrt{x})$.</p>
<div id="chart1_div" align=center></div>

<h4>A more complex example</h4>
<p>Consider $f(x)= x ( \exp(\sqrt{x}) + 1 ) + \sin(2\exp(\sqrt{x})+1)$.</p>
<div id="chart2_div" align=center></div>
<p>(here, SACADO fails)</p>

<h4>An example with three variables</h4>
<p>Consider $f(x,y,z)= (y+z) \sqrt{x}+\sin(\sqrt{x})$.</p>
<div id="chart3_div" align=center></div>


<br><h1>
<a id="optimization_strategies" class="anchor" href=#optimization_strategies aria-hidden="true"><span class="octicon octicon-link"></span></a>Optimization strategies</h1>
In order to get performance comparable to optimized manual implementations some optimization strategies are applied.

<h3>
<a id="optimization_strategies_inlining" class="anchor" href=#optimization_strategies_inlining aria-hidden="true"><span class="octicon octicon-link"></span></a>Inlining</h3>

<p>Since this library is based on code generation with template meta-programming and inlining, compiler rules for inlining have a strong influence on performance. The default rules, which work quite well in general, 
can be improved by adjusting specific parameters. For the examples in "Examples/Biomechanics" the choices
<ul>
<li>max-inline-insns-auto=3000</li>
<li>early-inlining-insns=5000</li>
<li>inline-unit-growth=100</li>
</ul>
for gcc-4.9.2 yields performance increases in the range of 2-4x. (see <a href=#performance>below</a>)</p>

<p>Note that adequate choices of the above parameters may be different when using this library in a larger project. For optimal performance you may think about compiling the function definition in a separate object file with 
compiler parameters as proposed above.</p>

<h3>
<a id="optimization_strategies_caching" class="anchor" href=#optimization_strategies_caching aria-hidden="true"><span class="octicon octicon-link"></span></a>Caching</h3>

<p>Significant performance increases are due to caching. In contrast to lazy evaluation, here the strategy is to compute intermediate results as soon as possible. This has various impacts. First the 
evaluation of cached results is one of the simplest function calls and is likely to be inlined. Moreover, in many expressions, the computed intermediate results can be reused in the computation of higher derivatives. Eventually, and most important, in many cases we can significantly reduce the size of temporaries as well as the number 
of generated temporaries by directly performing simple computations.</p>

<h3>
<a id="optimization_strategies_elimination_of_zeros" class="anchor" href=#optimization_strategies_elimination_of_zeros aria-hidden="true"><span class="octicon octicon-link"></span></a>Elimination of compile-time zeros</h3>

<p>Since we do not only want efficient evaluation of function values, but also of its first three derivatives, we often encounter larger number of compile-time zeros that can not be eliminated by the compiler. Thus this task must be implemented seperately. In order to completely eliminate compile-time zeros and correctly reduce involved mathematical expressions we do not define the corresponding derivatives. In particular when working with 
matrices, where only few operations are of higher order, this significantly reduces the computation times of the second and third derivative. </p>

<p>
A good example for the effects of this optimization strategy is the product $f=M(F^TF)$, which occurs in the computation of the first mixed strain invariant. In this context $M$ 
is treated as a constant and $F$ denotes the unknown and both are matrices in $\mathbb{R}^{3,3}$. For simplicity  we assume that we have a function $C=F^T F$.
The following graph illustrates the mathematical operations that are performed when evaluating the second derivative of this product.
</p>
<figure>
<img width=95% style="border-style: none" src="images/product_rule_d2_2.gif">
<figcaption>Mathematical operations required for the evaluation of the second derivative of the product rule.</figcaption>
</figure>
<p>Since all derivatives of $M$ vanish only the part marked in orange will be computed. The remaining computations are discarded during compilation.</p>



<br><h1>
<a id="performance" class="anchor" href=#performance aria-hidden="true"><span class="octicon octicon-link"></span></a>Performance for a model of muscle tissue</h1>
<p>
For functions that take matrices as arguments automatic differentation libraries can typically not be used directly. To get an idea of the performance, consider the function
\[\begin{align*}W(F)&amp;=c(\exp(b(\bar\iota_1-3))-1) + A(\exp(a(\bar\iota_6-1)^2)-1) \\ &amp;+d_0\Gamma_\mathrm{Inf}(\det(F))+d_1\Gamma_\mathrm{Com}(\det(F)), \end{align*}\]
with \[\begin{align*}\Gamma_\mathrm{Inf}(t) &amp;=t^2, \\ \Gamma_\mathrm{Com}(t) &amp;=\mathrm{ln}(t), \\ \bar\iota_1(C) &amp;=\mathrm{tr}(C)\det(C)^{-1/3}, \\ \bar\iota_6(C,M)&amp;=\mathrm{tr}(CM^2)\det(C)^{-1/3}, \end{align*}\]
with $C=F^T F$ and structural tensor $M$. Again each function is called 10.000.000 times with varying arguments.
</p>
<div id="chart4_div" align=center></div>
<p>
In the computations above compiler options as described in <a href=#optimization_strategies_inlining>Inlining</a> were used. Computation times only with <code>-02</code> are given below.
</p>
<div id="chart5_div" align=center></div>
<p>
Due to the extensive caching the call to <code>update</code> is more costly than the evaluation of <code>d0</code> or <code>d1</code>. As a consequence the call to <code>d0</code> is almost for free, since it only consists in copying the cached value. Large parts of the cached results can be reused, which is reflected in the small costs for the evaluation of <code>d1</code> and <code>d2</code>. In the computation of the third derivative the computations involving the perturbations start to dominate the overall computational costs.
</p>



<br><h1>
<a id="documentation" class="anchor" href=#documentation aria-hidden="true"><span class="octicon octicon-link"></span></a>Documentation</h1>

<p>Doxygen documentation can be found <a href="html/index.html">here</a>.</p>

<br><h1>
<a id="publications" class="anchor" href=#publications aria-hidden="true"><span class="octicon octicon-link"></span></a>Publications</h1>

<p>Preliminary versions of FunG have been used in:</p>
<ul>
<li>L. Lubkoll, A. Schiela, M. Weiser: <strong>An affine covariant composite step method for optimization with PDEs as equality constraints.</strong><br> Submitted at Opt. Meth. Soft., Preprint: ZIB-Report 15-09, 2015</li>
<li>L. Lubkoll: <strong>An Optimal Control Approach to Implant Shape Design: Modeling, Analysis and Numerics.</strong><br> Dissertation, submitted at Universit√§t Bayreuth, 2015</li>
</ul>

<br><h1>
<a id="talks" class="anchor" href=#talks aria-hidden="true"><span class="octicon octicon-link"></span></a>Talks</h1>
<ul>
<li><strong>FunG - Biomechanical Models in Modern C++</strong><br> DUNE User Meeting, Heidelberg, 28.09.2015 </li>
<li><strong>not to code</strong><br> C++-Meetup, Berlin, 19.05.2015</li>
</ul>


<p>Contact: <a href="mailto:lars.lubkoll@posteo.de">lars.lubkoll@posteo.de</a></p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">FunG maintained by <a href="https://github.com/lubkoll">lubkoll</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
