<p>Consider a function with two variables, a scalar variable x and a matrix valued variable F (which is assumed to be default constructible in this example): \[f(x,F)=\sqrt{x}\mathrm{tr}(F).\]</p>

<pre class="code-style boxshadow">#include "fung.hh"

template &lt; class Mat &gt;
auto generateFunction()
{
  using namespace FunG;
  using FunG::LinearAlgebra::trace;
  
  auto x = variable&lt;0&gt;( 0. );
  auto F = Variable&lt;Mat,1&gt;();

  return finalize( sqrt(x)*trace(F) );
}
</pre>

<p>When computing derivatives we now have to specify the variable ids for which the derivative will be computed. The same holds for setting the function values.</p>

<pre class="code-style boxshadow">auto f = generateFunction&lt; Mat &gt;();

f.template update&lt;0&gt;( x );
f.template update&lt;1&gt;( F );

double value       = f();
double df_dx       = f.template d1&lt;0&gt;( dx1 );
double df_dF       = f.template d1&lt;1&gt;( dF )
double ddf_dFdx    = f.template d2&lt;1,0&gt;( dF, dx1 );
double dddf_dxdxdF = f.template d3&lt;0,0,1&gt;( dx1, dx2, dF );
</pre> 

<p>The function <code>finalize</code> at the end of <code>generateFunction</code> is necessary to generate the suitable update function for f.</p>
