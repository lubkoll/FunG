<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Function Generation: RFFGen Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Function Generation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">RFFGen Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main namespace of the RFFGen library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRFFGen_1_1Constant.html">Constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a constant.  <a href="structRFFGen_1_1Constant.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRFFGen_1_1Identity.html">Identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity mapping <img class="formulaInl" alt="$ f(x)=x $" src="form_3.png"/>.  <a href="structRFFGen_1_1Identity.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRFFGen_1_1Variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Independent variable. Can be uniquely identified by its id.  <a href="structRFFGen_1_1Variable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRFFGen_1_1Base.html">Base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for functions satisfying FunctionConcept. Required for enabling the operators in <a class="el" href="generate_8hh_source.html">generate.hh</a>.  <a href="structRFFGen_1_1Base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRFFGen_1_1OutOfDomainException.html">OutOfDomainException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for scalar function arguments that are outside the domain of the function.  <a href="classRFFGen_1_1OutOfDomainException.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRFFGen_1_1NonSymmetricMatrixException.html">NonSymmetricMatrixException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for non-symmetric matrices if symmetric matrices are required.  <a href="classRFFGen_1_1NonSymmetricMatrixException.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRFFGen_1_1Zero.html">Zero</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize this struct for your matrix type if a zero matrix cannot be generated via Matrix(0.).  <a href="structRFFGen_1_1Zero.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRFFGen_1_1Zero_3_01Matrix_00_01void__t_3_01Checks_1_1TryCallToFill_3_01Matrix_01_4_01_4_01_4.html">Zero&lt; Matrix, void_t&lt; Checks::TryCallToFill&lt; Matrix &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the case that a matrix can be set to zero by calling the member function fill(0).  <a href="structRFFGen_1_1Zero_3_01Matrix_00_01void__t_3_01Checks_1_1TryCallToFill_3_01Matrix_01_4_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a394df0f2ab428f4a972b4d93900a5e04"><td class="memTemplParams" colspan="2">template&lt;class F , bool arithmeticArgument = false&gt; </td></tr>
<tr class="memitem:a394df0f2ab428f4a972b4d93900a5e04"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#a394df0f2ab428f4a972b4d93900a5e04">Finalize</a> = Detail::FinalizeImpl&lt; F, arithmeticArgument, Checks::hasVariable&lt; F &gt;() &gt;</td></tr>
<tr class="memdesc:a394df0f2ab428f4a972b4d93900a5e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish function definition.  <a href="#a394df0f2ab428f4a972b4d93900a5e04">More...</a><br/></td></tr>
<tr class="separator:a394df0f2ab428f4a972b4d93900a5e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6abb2e40c9688574411fd42898fab4"><td class="memTemplParams" colspan="2"><a class="anchor" id="acc6abb2e40c9688574411fd42898fab4"></a>
template&lt;class F , int id&gt; </td></tr>
<tr class="memitem:acc6abb2e40c9688574411fd42898fab4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#acc6abb2e40c9688574411fd42898fab4">Variable_t</a> = typename VariableDetail::VariableType&lt; F, id &gt;::type</td></tr>
<tr class="memdesc:acc6abb2e40c9688574411fd42898fab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get underlying type of variable with index id. <br/></td></tr>
<tr class="separator:acc6abb2e40c9688574411fd42898fab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e18569d04cc91cf19632c12cd4a0d8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a20e18569d04cc91cf19632c12cd4a0d8"></a>
template&lt;class... Types&gt; </td></tr>
<tr class="memitem:a20e18569d04cc91cf19632c12cd4a0d8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#a20e18569d04cc91cf19632c12cd4a0d8">void_t</a> = typename Detail::voider&lt; Types...&gt;::type</td></tr>
<tr class="memdesc:a20e18569d04cc91cf19632c12cd4a0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most fascinating type ever. Is always void. <br/></td></tr>
<tr class="separator:a20e18569d04cc91cf19632c12cd4a0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1e5703444079774f6e6a9161a9bacc6b"><td class="memTemplParams" colspan="2">template&lt;class Arg &gt; </td></tr>
<tr class="memitem:a1e5703444079774f6e6a9161a9bacc6b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#a1e5703444079774f6e6a9161a9bacc6b">constRef</a> (const Arg &amp;x)</td></tr>
<tr class="memdesc:a1e5703444079774f6e6a9161a9bacc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a constant function that stores its argument as constant reference.  <a href="#a1e5703444079774f6e6a9161a9bacc6b">More...</a><br/></td></tr>
<tr class="separator:a1e5703444079774f6e6a9161a9bacc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181c95df45572198e3e6bcac7616cd68"><td class="memTemplParams" colspan="2">template&lt;class Arg &gt; </td></tr>
<tr class="memitem:a181c95df45572198e3e6bcac7616cd68"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#a181c95df45572198e3e6bcac7616cd68">constant</a> (const Arg &amp;x)</td></tr>
<tr class="memdesc:a181c95df45572198e3e6bcac7616cd68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a constant.  <a href="#a181c95df45572198e3e6bcac7616cd68">More...</a><br/></td></tr>
<tr class="separator:a181c95df45572198e3e6bcac7616cd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d4bfae5fedad4740c0ab09cb4ff0a1"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ad0d4bfae5fedad4740c0ab09cb4ff0a1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#ad0d4bfae5fedad4740c0ab09cb4ff0a1">finalize</a> (const F &amp;f)</td></tr>
<tr class="memdesc:ad0d4bfae5fedad4740c0ab09cb4ff0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish function definition.  <a href="#ad0d4bfae5fedad4740c0ab09cb4ff0a1">More...</a><br/></td></tr>
<tr class="separator:ad0d4bfae5fedad4740c0ab09cb4ff0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6f6d638cd22c164c671c239486bb88"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a8a6f6d638cd22c164c671c239486bb88"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#a8a6f6d638cd22c164c671c239486bb88">finalize_scalar</a> (const F &amp;f)</td></tr>
<tr class="memdesc:a8a6f6d638cd22c164c671c239486bb88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish function definition.  <a href="#a8a6f6d638cd22c164c671c239486bb88">More...</a><br/></td></tr>
<tr class="separator:a8a6f6d638cd22c164c671c239486bb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fcf65f6c783e3da0a0007291f706ca"><td class="memTemplParams" colspan="2">template&lt;class F , class G , class  = std::enable_if_t&lt; std::is_base_of&lt;Base,F&gt;::value ||                                      std::is_base_of&lt;Base,G&gt;::value &gt;&gt; </td></tr>
<tr class="memitem:a45fcf65f6c783e3da0a0007291f706ca"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#a45fcf65f6c783e3da0a0007291f706ca">operator+</a> (const F &amp;f, const G &amp;g)</td></tr>
<tr class="memdesc:a45fcf65f6c783e3da0a0007291f706ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload of "+"-operator for the generation of functions.  <a href="#a45fcf65f6c783e3da0a0007291f706ca">More...</a><br/></td></tr>
<tr class="separator:a45fcf65f6c783e3da0a0007291f706ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab537e59af6c5a4f0f2a7469e8ae6461b"><td class="memTemplParams" colspan="2">template&lt;class F , class G , class  = std::enable_if_t&lt; std::is_base_of&lt;Base,F&gt;::value || std::is_base_of&lt;Base,G&gt;::value &gt;&gt; </td></tr>
<tr class="memitem:ab537e59af6c5a4f0f2a7469e8ae6461b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#ab537e59af6c5a4f0f2a7469e8ae6461b">operator*</a> (const F &amp;f, const G &amp;g)</td></tr>
<tr class="memdesc:ab537e59af6c5a4f0f2a7469e8ae6461b"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload of "*"-operator for the generation of functions.  <a href="#ab537e59af6c5a4f0f2a7469e8ae6461b">More...</a><br/></td></tr>
<tr class="separator:ab537e59af6c5a4f0f2a7469e8ae6461b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a4ba5900f079a4023c34cd620fc21d"><td class="memTemplParams" colspan="2">template&lt;class F , class  = std::enable_if_t&lt; std::is_base_of&lt;Base,F&gt;::value &gt;&gt; </td></tr>
<tr class="memitem:a59a4ba5900f079a4023c34cd620fc21d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#a59a4ba5900f079a4023c34cd620fc21d">operator^</a> (const F &amp;f, int k)</td></tr>
<tr class="memdesc:a59a4ba5900f079a4023c34cd620fc21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload of "^"-operator for the generation of functions.  <a href="#a59a4ba5900f079a4023c34cd620fc21d">More...</a><br/></td></tr>
<tr class="separator:a59a4ba5900f079a4023c34cd620fc21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c40e5d41ad211f6d861f2862a02e670"><td class="memTemplParams" colspan="2">template&lt;class F , class G , class  = std::enable_if_t&lt;std::is_base_of&lt;Base,F&gt;::value &amp;&amp;                                     std::is_base_of&lt;Base,G&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a2c40e5d41ad211f6d861f2862a02e670"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#a2c40e5d41ad211f6d861f2862a02e670">operator&lt;&lt;</a> (const F &amp;f, const G &amp;g)</td></tr>
<tr class="memdesc:a2c40e5d41ad211f6d861f2862a02e670"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload of "&lt;&lt;"-operator for chaining functions <img class="formulaInl" alt="$f$" src="form_0.png"/> and <img class="formulaInl" alt="$g$" src="form_1.png"/> to <img class="formulaInl" alt="$ f \circ g $" src="form_2.png"/>.  <a href="#a2c40e5d41ad211f6d861f2862a02e670">More...</a><br/></td></tr>
<tr class="separator:a2c40e5d41ad211f6d861f2862a02e670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933ac482bf44b977bbe2ce057362b55a"><td class="memTemplParams" colspan="2">template&lt;class F , class T , class  = std::enable_if_t&lt;std::is_convertible&lt;T,decltype(std::declval&lt;F&gt;().d0())&gt;::value &amp;&amp;                                     std::is_base_of&lt;Base,F&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a933ac482bf44b977bbe2ce057362b55a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#a933ac482bf44b977bbe2ce057362b55a">operator-</a> (const F &amp;f, const T &amp;t)</td></tr>
<tr class="memdesc:a933ac482bf44b977bbe2ce057362b55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload of "-"-operator for the generation of functions. Here the second argument is a constant that is wrapped in to an object of type <a class="el" href="structRFFGen_1_1Constant.html" title="Wrap a constant. ">Constant</a>.  <a href="#a933ac482bf44b977bbe2ce057362b55a">More...</a><br/></td></tr>
<tr class="separator:a933ac482bf44b977bbe2ce057362b55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b334216a1a47d21c0ecb857ad279580"><td class="memTemplParams" colspan="2">template&lt;class F , class T , class  = std::enable_if_t&lt;std::is_convertible&lt;T,decltype(std::declval&lt;F&gt;().d0())&gt;::value &amp;&amp;                                     std::is_base_of&lt;Base,F&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a7b334216a1a47d21c0ecb857ad279580"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#a7b334216a1a47d21c0ecb857ad279580">operator-</a> (const T &amp;t, const F &amp;f)</td></tr>
<tr class="memdesc:a7b334216a1a47d21c0ecb857ad279580"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload of "-"-operator for the generation of functions. Here the first argument is a constant that is wrapped in to an object of type <a class="el" href="structRFFGen_1_1Constant.html" title="Wrap a constant. ">Constant</a>.  <a href="#a7b334216a1a47d21c0ecb857ad279580">More...</a><br/></td></tr>
<tr class="separator:a7b334216a1a47d21c0ecb857ad279580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20942553f30cb8b3a7dc84b9581aeb3"><td class="memTemplParams" colspan="2"><a class="anchor" id="af20942553f30cb8b3a7dc84b9581aeb3"></a>
template&lt;class Arg &gt; </td></tr>
<tr class="memitem:af20942553f30cb8b3a7dc84b9581aeb3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#af20942553f30cb8b3a7dc84b9581aeb3">identity</a> (const Arg &amp;x)</td></tr>
<tr class="memdesc:af20942553f30cb8b3a7dc84b9581aeb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct Identity&lt;Arg&gt;(x). <br/></td></tr>
<tr class="separator:af20942553f30cb8b3a7dc84b9581aeb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff332846164ad83741fdb7b7f62a0d6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9ff332846164ad83741fdb7b7f62a0d6"></a>
template&lt;int id, class T &gt; </td></tr>
<tr class="memitem:a9ff332846164ad83741fdb7b7f62a0d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structRFFGen_1_1Variable.html">Variable</a>&lt; T, id &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#a9ff332846164ad83741fdb7b7f62a0d6">variable</a> (const T &amp;t)</td></tr>
<tr class="memdesc:a9ff332846164ad83741fdb7b7f62a0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate variable from input type. <br/></td></tr>
<tr class="separator:a9ff332846164ad83741fdb7b7f62a0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecd1bb1423c34a46a1bb55f6c79d65f"><td class="memTemplParams" colspan="2"><a class="anchor" id="acecd1bb1423c34a46a1bb55f6c79d65f"></a>
template&lt;class Inflation , class Compression , class Matrix &gt; </td></tr>
<tr class="memitem:acecd1bb1423c34a46a1bb55f6c79d65f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#acecd1bb1423c34a46a1bb55f6c79d65f">volumetricPenalty</a> (double d0, double d1, const Matrix &amp;A)</td></tr>
<tr class="memdesc:acecd1bb1423c34a46a1bb55f6c79d65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create volumetric penalty function composed of a penalty for inflation and one for compression. <br/></td></tr>
<tr class="separator:acecd1bb1423c34a46a1bb55f6c79d65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a0e5bc2796da63afa6a1ce529975e8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a78a0e5bc2796da63afa6a1ce529975e8"></a>
template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:a78a0e5bc2796da63afa6a1ce529975e8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#a78a0e5bc2796da63afa6a1ce529975e8">volumetricQuadAndLog</a> (double d0, double d1, const Matrix &amp;A)</td></tr>
<tr class="memdesc:a78a0e5bc2796da63afa6a1ce529975e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the volumetric penalty function <img class="formulaInl" alt="$ d_0 j^2 + d_1 \log(j),\ j=\det(A) $" src="form_4.png"/>. <br/></td></tr>
<tr class="separator:a78a0e5bc2796da63afa6a1ce529975e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b1b3749e9292f521920a9cded87ca7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a18b1b3749e9292f521920a9cded87ca7"></a>
template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:a18b1b3749e9292f521920a9cded87ca7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#a18b1b3749e9292f521920a9cded87ca7">volumetricHartmannNeff</a> (double d0, double d1, const Matrix &amp;A)</td></tr>
<tr class="memdesc:a18b1b3749e9292f521920a9cded87ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the volumetric penalty function <img class="formulaInl" alt="$ d_0 j^5 + d_1 j^{-5},\ j=\det(A) $" src="form_5.png"/>. <br/></td></tr>
<tr class="separator:a18b1b3749e9292f521920a9cded87ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17be470f8d1f282f788fa1b844ad3bb"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa17be470f8d1f282f788fa1b844ad3bb"></a>
template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:aa17be470f8d1f282f788fa1b844ad3bb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#aa17be470f8d1f282f788fa1b844ad3bb">yieldSurface</a> (double beta, double offset, Matrix sigma=LinearAlgebra::unitMatrix&lt; Matrix &gt;())</td></tr>
<tr class="memdesc:aa17be470f8d1f282f788fa1b844ad3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield surface <img class="formulaInl" alt="$ \frac{\beta}{3}\iota_1(\sigma) + J_2(\sigma)-offset $" src="form_6.png"/>, where <img class="formulaInl" alt="$\iota_1$" src="form_7.png"/> is the first principal and <img class="formulaInl" alt="$J_2$" src="form_8.png"/> is the second deviatoric invariant. <br/></td></tr>
<tr class="separator:aa17be470f8d1f282f788fa1b844ad3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8626dcc0c5d11d3d2d796d09457e5e5d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga8626dcc0c5d11d3d2d796d09457e5e5d"></a>
template&lt;class Matrix , int offset = LinearAlgebra::dimension&lt;Matrix&gt;()&gt; </td></tr>
<tr class="memitem:ga8626dcc0c5d11d3d2d796d09457e5e5d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Rubber.html#ga8626dcc0c5d11d3d2d796d09457e5e5d">incompressibleMooneyRivlin</a> (double c0, double c1, const Matrix &amp;F)</td></tr>
<tr class="memdesc:ga8626dcc0c5d11d3d2d796d09457e5e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an "incompressible" Mooney-Rivlin material law <img class="formulaInl" alt="$ W(F)=c_0\iota_1(F^T F) + c_1\iota_2(F^T F) $" src="form_9.png"/>, where <img class="formulaInl" alt="$\iota_1$" src="form_7.png"/> is the first and <img class="formulaInl" alt="$\iota_2$" src="form_10.png"/> the second principal matrix invariant. <br/></td></tr>
<tr class="separator:ga8626dcc0c5d11d3d2d796d09457e5e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1522c73c1e2eec5516b73b203150c7e1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1522c73c1e2eec5516b73b203150c7e1"></a>
template&lt;class InflationPenalty , class CompressionPenalty , class Matrix , int offset = LinearAlgebra::dimension&lt;Matrix&gt;()&gt; </td></tr>
<tr class="memitem:ga1522c73c1e2eec5516b73b203150c7e1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Rubber.html#ga1522c73c1e2eec5516b73b203150c7e1">compressibleMooneyRivlin</a> (double c0, double c1, double d0, double d1, const Matrix &amp;F)</td></tr>
<tr class="memdesc:ga1522c73c1e2eec5516b73b203150c7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a compressible Mooney-Rivlin material law <img class="formulaInl" alt="$ W(F)=c_0\iota_1(F^T F) + c_1\iota_2(F^T F) + d_0\Gamma_\mathrm{In}(\det(F))+d_1\Gamma_\mathrm{Co}(\det(F)) $" src="form_11.png"/>, where <img class="formulaInl" alt="$\iota_1$" src="form_7.png"/> is the first and <img class="formulaInl" alt="$\iota_2$" src="form_10.png"/> the second principal matrix invariant. <br/></td></tr>
<tr class="separator:ga1522c73c1e2eec5516b73b203150c7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga554b9bf515aa99d3bdc9e230f2a65bca"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga554b9bf515aa99d3bdc9e230f2a65bca"></a>
template&lt;class Matrix , int offset = LinearAlgebra::dimension&lt;Matrix&gt;()&gt; </td></tr>
<tr class="memitem:ga554b9bf515aa99d3bdc9e230f2a65bca"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Rubber.html#ga554b9bf515aa99d3bdc9e230f2a65bca">incompressibleNeoHooke</a> (double c, const Matrix &amp;F)</td></tr>
<tr class="memdesc:ga554b9bf515aa99d3bdc9e230f2a65bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an "incompressible" neo-Hookean material law <img class="formulaInl" alt="$ W(F)=c\iota_1(F^T F) $" src="form_18.png"/>, where <img class="formulaInl" alt="$\iota_1$" src="form_7.png"/> is the first principal matrix invariant . <br/></td></tr>
<tr class="separator:ga554b9bf515aa99d3bdc9e230f2a65bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b6f97c769ead09a5b1dcdf4733e85aa"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1b6f97c769ead09a5b1dcdf4733e85aa"></a>
template&lt;class Matrix , int offset = LinearAlgebra::dimension&lt;Matrix&gt;()&gt; </td></tr>
<tr class="memitem:ga1b6f97c769ead09a5b1dcdf4733e85aa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Rubber.html#ga1b6f97c769ead09a5b1dcdf4733e85aa">modifiedIncompressibleNeoHooke</a> (double c, const Matrix &amp;F)</td></tr>
<tr class="memdesc:ga1b6f97c769ead09a5b1dcdf4733e85aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an "incompressible" neo-Hookean material law <img class="formulaInl" alt="$ W(F)=c\bar\iota_1(F^T F) $" src="form_19.png"/>, where <img class="formulaInl" alt="$\bar\iota_1$" src="form_20.png"/> is the modified first principal matrix invariant. <br/></td></tr>
<tr class="separator:ga1b6f97c769ead09a5b1dcdf4733e85aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35a60a5ae50481becd543140ba82c171"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga35a60a5ae50481becd543140ba82c171"></a>
template&lt;class InflationPenalty , class CompressionPenalty , class Matrix , int offset = LinearAlgebra::dimension&lt;Matrix&gt;()&gt; </td></tr>
<tr class="memitem:ga35a60a5ae50481becd543140ba82c171"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Rubber.html#ga35a60a5ae50481becd543140ba82c171">compressibleNeoHooke</a> (double c, double d0, double d1, const Matrix &amp;F)</td></tr>
<tr class="memdesc:ga35a60a5ae50481becd543140ba82c171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a compressible neo-Hookean material law <img class="formulaInl" alt="$ W(F)=c\iota_1(F^T F)+d_0\Gamma_\mathrm{In}(\det(F))+d_1\Gamma_\mathrm{Co}(\det(F)) $" src="form_21.png"/>, where <img class="formulaInl" alt="$\iota_1$" src="form_7.png"/> is the first principal matrix invariant. <br/></td></tr>
<tr class="separator:ga35a60a5ae50481becd543140ba82c171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4985bcfe7726155b3b53f94094ebb3e"><td class="memTemplParams" colspan="2"><a class="anchor" id="gad4985bcfe7726155b3b53f94094ebb3e"></a>
template&lt;class InflationPenalty , class CompressionPenalty , class Matrix , int offset = LinearAlgebra::dimension&lt;Matrix&gt;()&gt; </td></tr>
<tr class="memitem:gad4985bcfe7726155b3b53f94094ebb3e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Rubber.html#gad4985bcfe7726155b3b53f94094ebb3e">modifiedCompressibleNeoHooke</a> (double c, double d0, double d1, const Matrix &amp;F)</td></tr>
<tr class="memdesc:gad4985bcfe7726155b3b53f94094ebb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a compressible neo-Hookean material law <img class="formulaInl" alt="$ W(F)=c\bar\iota_1(F^T F)+d_0\Gamma_\mathrm{In}(\det(F))+d_1\Gamma_\mathrm{Co}(\det(F)) $" src="form_22.png"/>, where <img class="formulaInl" alt="$\bar\iota_1$" src="form_20.png"/> is the modified first principal matrix invariant. <br/></td></tr>
<tr class="separator:gad4985bcfe7726155b3b53f94094ebb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ae9c0e3e217b82ca8020e716faac738"><td class="memTemplParams" colspan="2">template&lt;class Matrix , int offset = LinearAlgebra::dimension&lt;Matrix&gt;()&gt; </td></tr>
<tr class="memitem:ga8ae9c0e3e217b82ca8020e716faac738"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Biomechanics.html#ga8ae9c0e3e217b82ca8020e716faac738">incompressibleAdiposeTissue_SommerHolzapfel</a> (double cCells, double k1, double k2, double kappa, const Matrix &amp;M, const Matrix &amp;F)</td></tr>
<tr class="memdesc:ga8ae9c0e3e217b82ca8020e716faac738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Model for adipose tissue of Sommer et al.: Multiaxial mechanical properties and constitutive modeling of human adipose tissue: A basis for preoperative simulations in plastic and reconstructive surgery. Acta Biomater., 9:9036-9048, 2013.  <a href="group__Biomechanics.html#ga8ae9c0e3e217b82ca8020e716faac738">More...</a><br/></td></tr>
<tr class="separator:ga8ae9c0e3e217b82ca8020e716faac738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf78d6e032c8bd9b5ea67ac4329ef61d2"><td class="memTemplParams" colspan="2">template&lt;class Matrix , int offset = LinearAlgebra::dimension&lt;Matrix&gt;()&gt; </td></tr>
<tr class="memitem:gaf78d6e032c8bd9b5ea67ac4329ef61d2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Biomechanics.html#gaf78d6e032c8bd9b5ea67ac4329ef61d2">incompressibleAdiposeTissue_SommerHolzapfel</a> (const Matrix &amp;M, const Matrix &amp;F)</td></tr>
<tr class="memdesc:gaf78d6e032c8bd9b5ea67ac4329ef61d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Model for adipose tissue of Sommer et al.: Multiaxial mechanical properties and constitutive modeling of human adipose tissue: A basis for preoperative simulations in plastic and reconstructive surgery. Acta Biomater., 9:9036-9048, 2013.  <a href="group__Biomechanics.html#gaf78d6e032c8bd9b5ea67ac4329ef61d2">More...</a><br/></td></tr>
<tr class="separator:gaf78d6e032c8bd9b5ea67ac4329ef61d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c4a1bc765b6deb392a8151f02deaea8"><td class="memTemplParams" colspan="2">template&lt;class Inflation , class Compression , class Matrix , int offset = LinearAlgebra::dimension&lt;Matrix&gt;()&gt; </td></tr>
<tr class="memitem:ga4c4a1bc765b6deb392a8151f02deaea8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Biomechanics.html#ga4c4a1bc765b6deb392a8151f02deaea8">compressibleAdiposeTissue_SommerHolzapfel</a> (double cCells, double k1, double k2, double kappa, double d0, double d1, const Matrix &amp;M, const Matrix &amp;F)</td></tr>
<tr class="memdesc:ga4c4a1bc765b6deb392a8151f02deaea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressible version of the model for adipose tissue of Sommer et al.: Multiaxial mechanical properties and constitutive modeling of human adipose tissue: A basis for preoperative simulations in plastic and reconstructive surgery. Acta Biomater., 9:9036-9048, 2013.  <a href="group__Biomechanics.html#ga4c4a1bc765b6deb392a8151f02deaea8">More...</a><br/></td></tr>
<tr class="separator:ga4c4a1bc765b6deb392a8151f02deaea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f3e0d2799629dab092114d59233bc03"><td class="memTemplParams" colspan="2">template&lt;class Inflation , class Compression , class Matrix , int offset = LinearAlgebra::dimension&lt;Matrix&gt;()&gt; </td></tr>
<tr class="memitem:ga3f3e0d2799629dab092114d59233bc03"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Biomechanics.html#ga3f3e0d2799629dab092114d59233bc03">compressibleAdiposeTissue_SommerHolzapfel</a> (double d0, double d1, const Matrix &amp;M, const Matrix &amp;F)</td></tr>
<tr class="memdesc:ga3f3e0d2799629dab092114d59233bc03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressible version of the model for adipose tissue of Sommer et al.: Multiaxial mechanical properties and constitutive modeling of human adipose tissue: A basis for preoperative simulations in plastic and reconstructive surgery. Acta Biomater., 9:9036-9048, 2013. Material parameters are taken from the same publication, Table 2, i.e. <img class="formulaInl" alt="$c_\mathrm{Cells}=0.15 (\,\mathrm{kPa})$" src="form_29.png"/>, <img class="formulaInl" alt="$k_1=0.8 (\,\mathrm{kPa})$" src="form_30.png"/>, <img class="formulaInl" alt="$k_2=47.3$" src="form_31.png"/> and <img class="formulaInl" alt="$\kappa=0.09$" src="form_32.png"/>.  <a href="group__Biomechanics.html#ga3f3e0d2799629dab092114d59233bc03">More...</a><br/></td></tr>
<tr class="separator:ga3f3e0d2799629dab092114d59233bc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c85de42ee96ce8b8505dd22d2327e12"><td class="memTemplParams" colspan="2">template&lt;class Matrix , int offset = LinearAlgebra::dimension&lt;Matrix&gt;()&gt; </td></tr>
<tr class="memitem:ga6c85de42ee96ce8b8505dd22d2327e12"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Biomechanics.html#ga6c85de42ee96ce8b8505dd22d2327e12">incompressibleMuscleTissue_Martins</a> (double c, double b, double A, double a, const Matrix &amp;M, const Matrix &amp;F)</td></tr>
<tr class="memdesc:ga6c85de42ee96ce8b8505dd22d2327e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incompressible version of the model for muscle tissue of Martins et al.: A numerical model of passive and active bahevaior of skeletal muscles. Comp. Meth. Appl. Mech. Eng. 151:419-433, 1998.  <a href="group__Biomechanics.html#ga6c85de42ee96ce8b8505dd22d2327e12">More...</a><br/></td></tr>
<tr class="separator:ga6c85de42ee96ce8b8505dd22d2327e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79c7b90af1f57945e9c1c8e547d6e9ee"><td class="memTemplParams" colspan="2">template&lt;class Matrix , int offset = LinearAlgebra::dimension&lt;Matrix&gt;()&gt; </td></tr>
<tr class="memitem:ga79c7b90af1f57945e9c1c8e547d6e9ee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Biomechanics.html#ga79c7b90af1f57945e9c1c8e547d6e9ee">incompressibleMuscleTissue_Martins</a> (const Matrix &amp;M, const Matrix &amp;F)</td></tr>
<tr class="memdesc:ga79c7b90af1f57945e9c1c8e547d6e9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incompressible version of the model for muscle tissue of Martins et al.: A numerical model of passive and active bahevaior of skeletal muscles. Comp. Meth. Appl. Mech. Eng. 151:419-433, 1998.  <a href="group__Biomechanics.html#ga79c7b90af1f57945e9c1c8e547d6e9ee">More...</a><br/></td></tr>
<tr class="separator:ga79c7b90af1f57945e9c1c8e547d6e9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa21bcb424d6ea5a591e454bcfa9cec1"><td class="memTemplParams" colspan="2">template&lt;class Inflation , class Compression , class Matrix , int offset = LinearAlgebra::dimension&lt;Matrix&gt;()&gt; </td></tr>
<tr class="memitem:gaaa21bcb424d6ea5a591e454bcfa9cec1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Biomechanics.html#gaaa21bcb424d6ea5a591e454bcfa9cec1">compressibleMuscleTissue_Martins</a> (double c, double b, double A, double a, double d0, double d1, const Matrix &amp;M, const Matrix &amp;F)</td></tr>
<tr class="memdesc:gaaa21bcb424d6ea5a591e454bcfa9cec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressible version of the model for muscle tissue of Martins et al.: A numerical model of passive and active bahevaior of skeletal muscles. Comp. Meth. Appl. Mech. Eng. 151:419-433, 1998.  <a href="group__Biomechanics.html#gaaa21bcb424d6ea5a591e454bcfa9cec1">More...</a><br/></td></tr>
<tr class="separator:gaaa21bcb424d6ea5a591e454bcfa9cec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bd109a716f5eab7c263fa42cb66a937"><td class="memTemplParams" colspan="2">template&lt;class Inflation , class Compression , class Matrix , int offset = LinearAlgebra::dimension&lt;Matrix&gt;()&gt; </td></tr>
<tr class="memitem:ga3bd109a716f5eab7c263fa42cb66a937"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Biomechanics.html#ga3bd109a716f5eab7c263fa42cb66a937">compressibleMuscleTissue_Martins</a> (double d0, double d1, const Matrix &amp;M, const Matrix &amp;F)</td></tr>
<tr class="memdesc:ga3bd109a716f5eab7c263fa42cb66a937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressible version of the model for muscle tissue of Martins et al.: A numerical model of passive and active bahevaior of skeletal muscles. Comp. Meth. Appl. Mech. Eng. 151:419-433, 1998.  <a href="group__Biomechanics.html#ga3bd109a716f5eab7c263fa42cb66a937">More...</a><br/></td></tr>
<tr class="separator:ga3bd109a716f5eab7c263fa42cb66a937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c1299d3275e15fee450d33b69f3c537"><td class="memTemplParams" colspan="2">template&lt;class Matrix , int offset = LinearAlgebra::dimension&lt;Matrix&gt;()&gt; </td></tr>
<tr class="memitem:ga2c1299d3275e15fee450d33b69f3c537"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Biomechanics.html#ga2c1299d3275e15fee450d33b69f3c537">incompressibleSkin_Hendriks</a> (double c0, double c1, const Matrix &amp;F)</td></tr>
<tr class="memdesc:ga2c1299d3275e15fee450d33b69f3c537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Model for skin tissue of Hendriks: Mechanical behavior of human epidermal and dermal layers in vivo. PhD thesis, Technische Universiteit Eindhoven, 2005.  <a href="group__Biomechanics.html#ga2c1299d3275e15fee450d33b69f3c537">More...</a><br/></td></tr>
<tr class="separator:ga2c1299d3275e15fee450d33b69f3c537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae120c2a20a841a63c19cee23f7eba317"><td class="memTemplParams" colspan="2">template&lt;class Matrix , int offset = LinearAlgebra::dimension&lt;Matrix&gt;()&gt; </td></tr>
<tr class="memitem:gae120c2a20a841a63c19cee23f7eba317"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Biomechanics.html#gae120c2a20a841a63c19cee23f7eba317">incompressibleSkin_Hendriks</a> (const Matrix &amp;F)</td></tr>
<tr class="memdesc:gae120c2a20a841a63c19cee23f7eba317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Model for skin tissue of Hendriks: Mechanical behavior of human epidermal and dermal layers in vivo. PhD thesis, Technische Universiteit Eindhoven, 2005.  <a href="group__Biomechanics.html#gae120c2a20a841a63c19cee23f7eba317">More...</a><br/></td></tr>
<tr class="separator:gae120c2a20a841a63c19cee23f7eba317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga749204473b9790e8479bbbbe0b703694"><td class="memTemplParams" colspan="2">template&lt;class InflationPenalty , class CompressionPenalty , class Matrix , int offset = LinearAlgebra::dimension&lt;Matrix&gt;()&gt; </td></tr>
<tr class="memitem:ga749204473b9790e8479bbbbe0b703694"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Biomechanics.html#ga749204473b9790e8479bbbbe0b703694">compressibleSkin_Hendriks</a> (double c0, double c1, double d0, double d1, const Matrix &amp;F)</td></tr>
<tr class="memdesc:ga749204473b9790e8479bbbbe0b703694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressible version of the model for skin tissue of Hendriks: Mechanical behavior of human epidermal and dermal layers in vivo. PhD thesis, Technische Universiteit Eindhoven, 2005.  <a href="group__Biomechanics.html#ga749204473b9790e8479bbbbe0b703694">More...</a><br/></td></tr>
<tr class="separator:ga749204473b9790e8479bbbbe0b703694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3118f1e205132778f07607cf852d40d9"><td class="memTemplParams" colspan="2">template&lt;class InflationPenalty , class CompressionPenalty , class Matrix , int offset = LinearAlgebra::dimension&lt;Matrix&gt;()&gt; </td></tr>
<tr class="memitem:ga3118f1e205132778f07607cf852d40d9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Biomechanics.html#ga3118f1e205132778f07607cf852d40d9">compressibleSkin_Hendriks</a> (double d0, double d1, const Matrix &amp;F)</td></tr>
<tr class="memdesc:ga3118f1e205132778f07607cf852d40d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressible version of the model for skin tissue of Hendriks: Mechanical behavior of human epidermal and dermal layers in vivo. PhD thesis, Technische Universiteit Eindhoven, 2005.  <a href="group__Biomechanics.html#ga3118f1e205132778f07607cf852d40d9">More...</a><br/></td></tr>
<tr class="separator:ga3118f1e205132778f07607cf852d40d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd7fec7e527b37833fc9fab6692da80"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8dd7fec7e527b37833fc9fab6692da80"></a>
template&lt;class Arg , class  = std::enable_if_t&lt; !std::is_base_of&lt;Base,Arg&gt;() &amp;&amp; !std::is_arithmetic&lt;Arg&gt;() &gt;, class  = std::enable_if_t&lt; !Checks::summation&lt;Arg&gt;() &amp;&amp;                                       Checks::inPlaceSummation&lt;Arg&gt;() &gt;&gt; </td></tr>
<tr class="memitem:a8dd7fec7e527b37833fc9fab6692da80"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#a8dd7fec7e527b37833fc9fab6692da80">operator+</a> (Arg x, const Arg &amp;y)</td></tr>
<tr class="memdesc:a8dd7fec7e527b37833fc9fab6692da80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines operator+ if not yet defined and in-place summation (operator+=()) is supported. <br/></td></tr>
<tr class="separator:a8dd7fec7e527b37833fc9fab6692da80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fbbf79f13356b1bbc8f70ec72df15c"><td class="memTemplParams" colspan="2"><a class="anchor" id="af8fbbf79f13356b1bbc8f70ec72df15c"></a>
template&lt;class Arg , class ScalarArg , class  = std::enable_if_t&lt; std::is_arithmetic&lt;ScalarArg&gt;::value &gt;, class  = std::enable_if_t&lt; !std::is_base_of&lt;Base,Arg&gt;() &amp;&amp; !std::is_arithmetic&lt;Arg&gt;() &gt;, class  = std::enable_if_t&lt; !Checks::multiplicationWithArithmeticFromLeft&lt;Arg,ScalarArg&gt;() &amp;&amp;                                       Checks::inPlaceMultiplicationWithArithmetic&lt;Arg,ScalarArg&gt;() &gt;&gt; </td></tr>
<tr class="memitem:af8fbbf79f13356b1bbc8f70ec72df15c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#af8fbbf79f13356b1bbc8f70ec72df15c">operator*</a> (ScalarArg a, Arg x)</td></tr>
<tr class="memdesc:af8fbbf79f13356b1bbc8f70ec72df15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines operator* for multiplication with built-in arithmetic types from the left if undefined and in-place multiplication (operator*=()) is supported. <br/></td></tr>
<tr class="separator:af8fbbf79f13356b1bbc8f70ec72df15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b6636f13ac62c184a835f740600599"><td class="memTemplParams" colspan="2"><a class="anchor" id="a93b6636f13ac62c184a835f740600599"></a>
template&lt;class Arg , class ScalarArg , class  = std::enable_if_t&lt; std::is_arithmetic&lt;ScalarArg&gt;::value &gt;, class  = std::enable_if_t&lt; !std::is_base_of&lt;Base,Arg&gt;() &amp;&amp; !std::is_arithmetic&lt;Arg&gt;::value&gt;, class  = std::enable_if_t&lt; !Checks::multiplicationWithArithmeticFromRight&lt;Arg,ScalarArg&gt;() &amp;&amp;                                       Checks::inPlaceMultiplicationWithArithmetic&lt;Arg,ScalarArg&gt;() &gt;&gt; </td></tr>
<tr class="memitem:a93b6636f13ac62c184a835f740600599"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#a93b6636f13ac62c184a835f740600599">operator*</a> (Arg x, ScalarArg a)</td></tr>
<tr class="memdesc:a93b6636f13ac62c184a835f740600599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines operator* for multiplication with built-in arithmetic types from the right if undefined and in-place multiplication (operator*=()) is supported. <br/></td></tr>
<tr class="separator:a93b6636f13ac62c184a835f740600599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addccbcc59d562d0b8c61f084e40b692b"><td class="memTemplParams" colspan="2"><a class="anchor" id="addccbcc59d562d0b8c61f084e40b692b"></a>
template&lt;class Arg1 , class Arg2 , class  = std::enable_if_t&lt; !std::is_base_of&lt;Arg1,Base&gt;() &amp;&amp; !std::is_base_of&lt;Arg2,Base&gt;() &gt;, class  = std::enable_if_t&lt; !std::is_arithmetic&lt;Arg1&gt;() &amp;&amp; !std::is_arithmetic&lt;Arg2&gt;() &gt;, class  = std::enable_if_t&lt; !Checks::multiplication&lt;Arg1,Arg2&gt;() &amp;&amp;                                       Checks::inPlaceMultiplication&lt;Arg1,Arg2&gt;() &gt;&gt; </td></tr>
<tr class="memitem:addccbcc59d562d0b8c61f084e40b692b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#addccbcc59d562d0b8c61f084e40b692b">operator*</a> (Arg1 x, const Arg2 &amp;y)</td></tr>
<tr class="memdesc:addccbcc59d562d0b8c61f084e40b692b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines operator* for multiplication of non-arithmetic types if undefined and in-place multiplication (operator*=()) is supported. <br/></td></tr>
<tr class="separator:addccbcc59d562d0b8c61f084e40b692b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5346beba60bcf5a97585baa6d62e72"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5a5346beba60bcf5a97585baa6d62e72"></a>
template&lt;class Arg1 , class Arg2 , class  = std::enable_if_t&lt; !std::is_base_of&lt;Arg1,Base&gt;() &amp;&amp; !std::is_base_of&lt;Arg2,Base&gt;() &gt;, class  = std::enable_if_t&lt; !std::is_arithmetic&lt;Arg1&gt;() &amp;&amp; !std::is_arithmetic&lt;Arg2&gt;() &gt;, class  = std::enable_if_t&lt; !Checks::multiplication&lt;Arg1,Arg2&gt;() &amp;&amp;                                       !Checks::inPlaceMultiplication&lt;Arg1,Arg2&gt;() &gt;, class  = std::enable_if_t&lt; Checks::callToRightMultiply&lt;Arg1,Arg2&gt;() &gt;&gt; </td></tr>
<tr class="memitem:a5a5346beba60bcf5a97585baa6d62e72"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#a5a5346beba60bcf5a97585baa6d62e72">operator*</a> (Arg1 x, const Arg2 &amp;y)</td></tr>
<tr class="memdesc:a5a5346beba60bcf5a97585baa6d62e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines operator* for multiplication of non-arithmetic types if undefined and in-place multiplication is provided in terms of the member function rightmultiplyany() (such as for Dune::FieldMatrix). <br/></td></tr>
<tr class="separator:a5a5346beba60bcf5a97585baa6d62e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35cec985ea0b25a40ada14189fba44d"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class  = std::enable_if_t&lt;Checks::isConstantSizeMatrix&lt;Matrix&gt;()&gt;&gt; </td></tr>
<tr class="memitem:aa35cec985ea0b25a40ada14189fba44d"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#aa35cec985ea0b25a40ada14189fba44d">addTransposed</a> (Matrix &amp;A)</td></tr>
<tr class="memdesc:aa35cec985ea0b25a40ada14189fba44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites <img class="formulaInl" alt="$A$" src="form_125.png"/> with <img class="formulaInl" alt="$A+A^T$" src="form_126.png"/>.  <a href="#aa35cec985ea0b25a40ada14189fba44d">More...</a><br/></td></tr>
<tr class="separator:aa35cec985ea0b25a40ada14189fba44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef418735161dcbe64af19269329865e"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class  = std::enable_if_t&lt;!Checks::isConstantSizeMatrix&lt;Matrix&gt;()&gt;, class  = std::enable_if_t&lt;Checks::isDynamicMatrix&lt;Matrix&gt;()&gt;&gt; </td></tr>
<tr class="memitem:adef418735161dcbe64af19269329865e"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#adef418735161dcbe64af19269329865e">addTransposed</a> (Matrix &amp;A)</td></tr>
<tr class="memdesc:adef418735161dcbe64af19269329865e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites <img class="formulaInl" alt="$A$" src="form_125.png"/> with <img class="formulaInl" alt="$A+A^T$" src="form_126.png"/>.  <a href="#adef418735161dcbe64af19269329865e">More...</a><br/></td></tr>
<tr class="separator:adef418735161dcbe64af19269329865e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d0192aaeb22d4afe3c2f523524f3ac"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class  = std::enable_if_t&lt;Checks::isConstantSizeMatrix&lt;Matrix&gt;()&gt;&gt; </td></tr>
<tr class="memitem:a63d0192aaeb22d4afe3c2f523524f3ac"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#a63d0192aaeb22d4afe3c2f523524f3ac">zero</a> ()</td></tr>
<tr class="separator:a63d0192aaeb22d4afe3c2f523524f3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad3b71c6132f265349b58702649eb32"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class  = std::enable_if_t&lt;!Checks::isConstantSizeMatrix&lt;Matrix&gt;()&gt;&gt; </td></tr>
<tr class="memitem:a0ad3b71c6132f265349b58702649eb32"><td class="memTemplItemLeft" align="right" valign="top">constexpr Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRFFGen.html#a0ad3b71c6132f265349b58702649eb32">zero</a> (int rows, int cols)</td></tr>
<tr class="separator:a0ad3b71c6132f265349b58702649eb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main namespace of the RFFGen library. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespaceMathematicalOperations.html" title="Mathematical operations and corresponding differentation rules. ">MathematicalOperations</a> </dd>
<dd>
<a class="el" href="namespaceCMath.html" title="Wrappers for functions from &lt;cmath&gt;. ">CMath</a> </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a394df0f2ab428f4a972b4d93900a5e04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , bool arithmeticArgument = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRFFGen.html#a394df0f2ab428f4a972b4d93900a5e04">RFFGen::Finalize</a> = typedef Detail::FinalizeImpl&lt; F , arithmeticArgument , Checks::hasVariable&lt;F&gt;() &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finish function definition. </p>
<p>Adds the definition of possibly undefined vanishing higher order derivatives. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aa35cec985ea0b25a40ada14189fba44d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class  = std::enable_if_t&lt;Checks::isConstantSizeMatrix&lt;Matrix&gt;()&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix RFFGen::addTransposed </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrites <img class="formulaInl" alt="$A$" src="form_125.png"/> with <img class="formulaInl" alt="$A+A^T$" src="form_126.png"/>. </p>
<dl class="section return"><dt>Returns</dt><dd><img class="formulaInl" alt="$A+A^T$" src="form_126.png"/> </dd></dl>

</div>
</div>
<a class="anchor" id="adef418735161dcbe64af19269329865e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class  = std::enable_if_t&lt;!Checks::isConstantSizeMatrix&lt;Matrix&gt;()&gt;, class  = std::enable_if_t&lt;Checks::isDynamicMatrix&lt;Matrix&gt;()&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix RFFGen::addTransposed </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrites <img class="formulaInl" alt="$A$" src="form_125.png"/> with <img class="formulaInl" alt="$A+A^T$" src="form_126.png"/>. </p>
<dl class="section return"><dt>Returns</dt><dd><img class="formulaInl" alt="$A+A^T$" src="form_126.png"/> </dd></dl>

</div>
</div>
<a class="anchor" id="a181c95df45572198e3e6bcac7616cd68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Arg &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RFFGen::constant </td>
          <td>(</td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap a constant. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant&lt;Arg&gt;(x) </dd></dl>

</div>
</div>
<a class="anchor" id="a1e5703444079774f6e6a9161a9bacc6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Arg &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RFFGen::constRef </td>
          <td>(</td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a constant function that stores its argument as constant reference. </p>
<p>This admits to use variable constant arguments, i.e. parameters that we want to study. </p>

</div>
</div>
<a class="anchor" id="ad0d4bfae5fedad4740c0ab09cb4ff0a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RFFGen::finalize </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finish function definition. </p>
<p>Adds the definition of possibly undefined vanishing higher order derivatives. </p>

</div>
</div>
<a class="anchor" id="a8a6f6d638cd22c164c671c239486bb88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RFFGen::finalize_scalar </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finish function definition. </p>
<p>Adds the definition of possibly undefined vanishing higher order derivatives. </p>

</div>
</div>
<a class="anchor" id="ab537e59af6c5a4f0f2a7469e8ae6461b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class G , class  = std::enable_if_t&lt; std::is_base_of&lt;Base,F&gt;::value || std::is_base_of&lt;Base,G&gt;::value &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RFFGen::operator* </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const G &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>overload of "*"-operator for the generation of functions. </p>
<p>This is not to be confused with delayed computations with expression templates. This operator is only used to admit intuitive definition of functions. If the resulting type represents a polynomial of order smaller than two, than you need to wrap it into Finalize to generate missing derivatives. </p>

</div>
</div>
<a class="anchor" id="a45fcf65f6c783e3da0a0007291f706ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class G , class  = std::enable_if_t&lt; std::is_base_of&lt;Base,F&gt;::value ||                                      std::is_base_of&lt;Base,G&gt;::value &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RFFGen::operator+ </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const G &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>overload of "+"-operator for the generation of functions. </p>
<p>This is not to be confused with delayed computations with expression templates. This operator is only used to admit intuitive definition of functions. If the resulting type represents a polynomial of order smaller than two, than you need to wrap it into Finalize to generate missing derivatives. </p>

</div>
</div>
<a class="anchor" id="a933ac482bf44b977bbe2ce057362b55a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T , class  = std::enable_if_t&lt;std::is_convertible&lt;T,decltype(std::declval&lt;F&gt;().d0())&gt;::value &amp;&amp;                                     std::is_base_of&lt;Base,F&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RFFGen::operator- </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>overload of "-"-operator for the generation of functions. Here the second argument is a constant that is wrapped in to an object of type <a class="el" href="structRFFGen_1_1Constant.html" title="Wrap a constant. ">Constant</a>. </p>
<p>This is not to be confused with delayed computations with expression templates. This operator is only used to admit intuitive definition of functions. If the resulting type represents a polynomial of order smaller than two, than you need to wrap it into Finalize to generate missing derivatives. </p>

</div>
</div>
<a class="anchor" id="a7b334216a1a47d21c0ecb857ad279580"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T , class  = std::enable_if_t&lt;std::is_convertible&lt;T,decltype(std::declval&lt;F&gt;().d0())&gt;::value &amp;&amp;                                     std::is_base_of&lt;Base,F&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RFFGen::operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>overload of "-"-operator for the generation of functions. Here the first argument is a constant that is wrapped in to an object of type <a class="el" href="structRFFGen_1_1Constant.html" title="Wrap a constant. ">Constant</a>. </p>
<p>This is not to be confused with delayed computations with expression templates. This operator is only used to admit intuitive definition of functions. If the resulting type represents a polynomial of order smaller than two, than you need to wrap it into Finalize to generate missing derivatives. </p>

</div>
</div>
<a class="anchor" id="a2c40e5d41ad211f6d861f2862a02e670"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class G , class  = std::enable_if_t&lt;std::is_base_of&lt;Base,F&gt;::value &amp;&amp;                                     std::is_base_of&lt;Base,G&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RFFGen::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const G &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>overload of "&lt;&lt;"-operator for chaining functions <img class="formulaInl" alt="$f$" src="form_0.png"/> and <img class="formulaInl" alt="$g$" src="form_1.png"/> to <img class="formulaInl" alt="$ f \circ g $" src="form_2.png"/>. </p>
<p>This is not to be confused with delayed computations with expression templates. This operator is only used to admit intuitive definition of functions. If the resulting type represents a polynomial of order smaller than two, than you need to wrap it into Finalize to generate missing derivatives. </p>

</div>
</div>
<a class="anchor" id="a59a4ba5900f079a4023c34cd620fc21d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class  = std::enable_if_t&lt; std::is_base_of&lt;Base,F&gt;::value &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RFFGen::operator^ </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>overload of "^"-operator for the generation of functions. </p>
<p>This is not to be confused with delayed computations with expression templates. This operator is only used to admit intuitive definition of functions. If the resulting type represents a polynomial of order smaller than two, than you need to wrap it into Finalize to generate missing derivatives. </p>

</div>
</div>
<a class="anchor" id="a63d0192aaeb22d4afe3c2f523524f3ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class  = std::enable_if_t&lt;Checks::isConstantSizeMatrix&lt;Matrix&gt;()&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix RFFGen::zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requires that a specialization of struct <a class="el" href="structRFFGen_1_1Zero.html" title="Specialize this struct for your matrix type if a zero matrix cannot be generated via Matrix(0...">Zero</a> exists for Matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>constant size zero matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a0ad3b71c6132f265349b58702649eb32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class  = std::enable_if_t&lt;!Checks::isConstantSizeMatrix&lt;Matrix&gt;()&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr Matrix RFFGen::zero </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requires that a specialization of struct <a class="el" href="structRFFGen_1_1Zero.html" title="Specialize this struct for your matrix type if a zero matrix cannot be generated via Matrix(0...">Zero</a> exists for Matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>dynamic size zero matrix </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jul 14 2015 17:35:44 for Function Generation by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
