{"name":"RFFGen","tagline":"A fast and easy to use function generation library that gives provides access to the first three derivatives of a (possibly matrix-valued) function.","body":"[![Build Status](https://travis-ci.org/lubkoll/RFFGen.svg?branch=master)](https://travis-ci.org/lubkoll/RFFGen/builds) [![Coverage Status](https://coveralls.io/repos/lubkoll/RFFGen/badge.svg)](https://coveralls.io/r/lubkoll/RFFGen)\r\n\r\n# RFFGen\r\nA fast and easy to use function generation library that gives provides access to the first three derivatives of a function.\r\n\r\nFunction arguments can be matrices and/or scalars. Vectors are also possible but most functionality targets on matrices.\r\n\r\n# Installation\r\nThis library is header-only and no installation is required.\r\n\r\nIf you want to run the available tests, you can use cmake:\r\n - mkdir build\r\n - cd build\r\n - cmake ..\r\n - make\r\n\r\n# Examples\r\n\r\nUsage is illustrated using three different examples. Further examples can be found in RFFGen/Tests and RFFGen/Examples.\r\n\r\n### A simple example\r\nWe begin with the function\r\n\r\n![equation](http://latex.codecogs.com/gif.latex?f%28x%29%3D%5Csqrt%7Bx%5E3%7D+%5Csin%28%5Csqrt%7Bx%7D%29%3D%28h%5Ccirc%20g%29%28x%29)\r\n\r\nwith\r\n\r\n![equation](http://latex.codecogs.com/gif.latex?h%28x%29%3Dx%5E3+%5Csin%28x%29)\r\n\r\nand\r\n\r\n![equation](http://latex.codecogs.com/gif.latex?g%28x%29%3D%5Csqrt%7Bx%7D)\r\n```\r\n#include \"RFFGen.hh\"\r\n\r\nauto generateFunction()\r\n{\r\n  using namespace RFFGen::CMath;\r\n  \r\n  auto h = Pow<3>() + Sin();\r\n  auto g = Sqrt();\r\n  \r\n  return RFFGen::finalize_scalar( h(g) );\r\n}\r\n```\r\nUsage is as follows:\r\n```\r\nauto f = generateFunction();\r\n\r\nf.update(1.) //  change function argument\r\n\r\nauto value = f(); // or f.d0()\r\nauto firstDerivative  = f.d1();\r\nauto secondDerivative = f.d2();\r\nauto thirdDerivative  = f.d3();\r\n```\r\nThe call to `finalize_scalar` is necessary to simplify usage of the generated function. Without usage is slightly less convenient as illustrated in the other examples below. \r\n\r\n### An example from biomechanics\r\nNow let us generate the function\r\n\r\n![equation](http://latex.codecogs.com/gif.latex?W%28F%29%3D%20c_%7BCells%7D%28%5Ciota_1-3%29+%20%5Cfrac%7Bk_1%7D%7Bk_2%7D%5Cexp%28k_2%5B%5Ckappa%5Ciota_1+%281-3%5Ckappa%29%5Ciota_4-1%5D%5E2-1%29)\r\n\r\nwhich constitutes a model for adipose tissue. In this context the invariants depend on the left Cauchy-Green strain tensor. Its implementation is\r\n```\r\n#include \"RFFGen.hh\"\r\n\r\ntemplate <class Mat>\r\nauto generateAdiposeTissue(double cCells, double k1, double k2,\r\n             double kappa, const Matrix& M, const Matrix& F)\r\n{\r\n  using namespace RFFGen::LinearAlgebra;\r\n  using RFFGen::CMath::exp;\r\n  using RFFGen::finalize;\r\n\r\n  auto i1 = FirstPrincipalInvariant<Matrix>();\r\n  auto si1 = ShiftedFirstPrincipalInvariant<Matrix>();\r\n  auto i4 = FirstMixedInvariant<Matrix>(F,M);\r\n \t\r\n  auto aniso = kappa*i1 + (1-3*kappa) * i4 - 1;\r\n  auto materialLaw = cCells*si1 + (k1/k2) * ( exp(aniso^2) - 1 );\r\n\r\n return finalize( materialLaw( LeftCauchyGreenStrainTensor<Matrix>(F) ) );\r\n}\r\n```\r\n\r\nUsage is as follows (assuming that the material parameters, the structural tensor M, the deformation gradient F and perturbations dF0, dF1, dF2 of the latter are given):\r\n```\r\nauto f = generateAdiposeTissue(cCells,k1,k2,kappa,M,F);\r\n\r\nf.update(F) //  change function argument\r\n\r\ndouble value = f(); // or f.d0()\r\ndouble firstDerivative  = f.d1(dF0);\r\ndouble secondDerivative = f.d2(dF0,dF1);\r\ndouble thirdDerivative  = f.d3(dF0,dF1,dF2);\r\n```\r\n\r\nObserve that the derivatives are DIRECTIONAL derivatives. This approach admits to work with any (reasonable) input types. In the first example, where the input variable was a scalar, the call to finalize_scalar did generate \r\nsuitable default values for the directions. Here this is not admissible. \r\n\r\nTake care to not use functions such as 'exp' with built-in arithmetic types, since in this case the corresponding functions from <cmath> are called and the resulting value is treated as constant.\r\n\r\n### An example with two variables\r\nEventually we consider a function with two variables, a scalar variable x and a matrix valued variable F.\r\n\r\n![equation](http://latex.codecogs.com/gif.latex?f%28x%2CF%29%3D%5Csqrt%7Bx%7D%5Cmathrm%7Btr%7D%28F%29)\r\n\r\n```\r\n#include \"RFFGen.hh\"\r\n\r\ntemplate <class Mat>\r\nauto generateFunction()\r\n{\r\n  using RFFGen::CMath::sqrt;\r\n  using RFFGen::LinearAlgebra::trace;\r\n  using RFFGen::Variable;\r\n  \r\n  auto x = Variable<double,0>();\r\n  auto F = Variable<Mat,1>();\r\n  \r\n  return RFFGen::finalize( sqrt(x)*trace(F) );\r\n}\r\n```\r\n\r\nWhen computing derivatives we now have to specify the variable ids for which the derivative will be computed. The same holds for setting the function values.\r\n\r\n```\r\nauto f = generateFunction<Mat>();\r\n\r\nf.template update<0>(x);\r\nf.template update<1>(F);\r\n\r\ndouble value       = f(); // or f.d0()\r\ndouble df_dx       = f.template d1<0>(dx1);\r\ndouble df_dF       = f.template d1<1>(dF)\r\ndouble ddf_dFdx    = f.template d2<1,0>(dF,dx1);\r\ndouble dddf_dxdxdF = f.template d3<0,0,1>(dx1,dx2,dF);\r\n```\r\n\r\n### Documentation\r\n\r\nDoxygen documentation is available <a href=\"doc/html/index.html\">here.</a> \r\n\r\nContact: lars.lubkoll@posteo.de\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}